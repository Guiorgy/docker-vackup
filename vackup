#!/usr/bin/env bash

# Docker Volume File Backup and Restore Tool
# Easily tar up a volume on a local (or remote) engine
# Base on vackup by Bret Fisher
# Inspired by CLIP from Lukasz Lach

if [ -z "$LINENO" ]; then
  LINENO='unknown'
fi

if command -v caller 1> /dev/null 2>&1; then
  CALLER=1
else
  CALLER=0
fi

if [ -z "$BASH" ]; then
  BASH=''
fi

if [ -z "$VACKUP_FAILURE_SCRIPT" ]; then
  VACKUP_FAILURE_SCRIPT=''
fi

if [ -n "$BASH" ]; then
  set -Eeuo pipefail
else
  set -eu
fi

handle_error() {
  case $# in
    1) LINE_NUMBER=$1; EXIT_CODE=$? ;;
    2) LINE_NUMBER=$1; EXIT_CODE=$2 ;;
    *) LINE_NUMBER=$LINENO; EXIT_CODE=1 ;;
  esac

  if [ -n "$VACKUP_FAILURE_SCRIPT" ]; then
    /usr/bin/env bash "$VACKUP_FAILURE_SCRIPT" "$LINE_NUMBER" $EXIT_CODE
  fi

  exit $EXIT_CODE
}

if [ -n "$BASH" ]; then
  trap 'handle_error $LINENO' ERR
else
  trap 'handle_error $LINENO $?' EXIT
fi

if [ -t 1 ]; then
  RESET_COLOR='\033[0m'

  BLACK_COLOR='\033[0;30m'
  RED_COLOR='\033[0;31m'
  GREEN_COLOR='\033[0;32m'
  YELLOW_COLOR='\033[0;33m'
  BLUE_COLOR='\033[0;34m'
  PURPLE_COLOR='\033[0;35m'
  CYAN_COLOR='\033[0;36m'
  WHITE_COLOR='\033[0;37m'

  BOLD_BLACK_COLOR='\033[1;30m'
  BOLD_RED_COLOR='\033[1;31m'
  BOLD_GREEN_COLOR='\033[1;32m'
  BOLD_YELLOW_COLOR='\033[1;33m'
  BOLD_BLUE_COLOR='\033[1;34m'
  BOLD_PURPLE_COLOR='\033[1;35m'
  BOLD_CYAN_COLOR='\033[1;36m'
  BOLD_WHITE_COLOR='\033[1;37m'
else
  RESET_COLOR=''

  BLACK_COLOR=''
  RED_COLOR=''
  GREEN_COLOR=''
  YELLOW_COLOR=''
  BLUE_COLOR=''
  PURPLE_COLOR=''
  CYAN_COLOR=''
  WHITE_COLOR=''

  BOLD_BLACK_COLOR=''
  BOLD_RED_COLOR=''
  BOLD_GREEN_COLOR=''
  BOLD_YELLOW_COLOR=''
  BOLD_BLUE_COLOR=''
  BOLD_PURPLE_COLOR=''
  BOLD_CYAN_COLOR=''
  BOLD_WHITE_COLOR=''
fi

if [ -t 2 ]; then
  RESET_COLOR_ERR='\033[0m'

  BLACK_COLOR_ERR='\033[0;30m'
  RED_COLOR_ERR='\033[0;31m'
  GREEN_COLOR_ERR='\033[0;32m'
  YELLOW_COLOR_ERR='\033[0;33m'
  BLUE_COLOR_ERR='\033[0;34m'
  PURPLE_COLOR_ERR='\033[0;35m'
  CYAN_COLOR_ERR='\033[0;36m'
  WHITE_COLOR_ERR='\033[0;37m'

  BOLD_BLACK_COLOR_ERR='\033[1;30m'
  BOLD_RED_COLOR_ERR='\033[1;31m'
  BOLD_GREEN_COLOR_ERR='\033[1;32m'
  BOLD_YELLOW_COLOR_ERR='\033[1;33m'
  BOLD_BLUE_COLOR_ERR='\033[1;34m'
  BOLD_PURPLE_COLOR_ERR='\033[1;35m'
  BOLD_CYAN_COLOR_ERR='\033[1;36m'
  BOLD_WHITE_COLOR_ERR='\033[1;37m'
else
  RESET_COLOR_ERR=''

  BLACK_COLOR_ERR=''
  RED_COLOR_ERR=''
  GREEN_COLOR_ERR=''
  YELLOW_COLOR_ERR=''
  BLUE_COLOR_ERR=''
  PURPLE_COLOR_ERR=''
  CYAN_COLOR_ERR=''
  WHITE_COLOR_ERR=''

  BOLD_BLACK_COLOR_ERR=''
  BOLD_RED_COLOR_ERR=''
  BOLD_GREEN_COLOR_ERR=''
  BOLD_YELLOW_COLOR_ERR=''
  BOLD_BLUE_COLOR_ERR=''
  BOLD_PURPLE_COLOR_ERR=''
  BOLD_CYAN_COLOR_ERR=''
  BOLD_WHITE_COLOR_ERR=''
fi

print_usage() {
  STDERR=0
  EXIT=0

  while [ $# -ne 0 ]; do
    case "$1" in
      --err) STDERR=1 ;;
      --exit) EXIT=1 ;;
    esac

    shift
  done

  TEXT=$(cat <<EOF

"Docker Volume Backup". Replicates image management commands for volumes.

export/import copies files between a host tarball and a volume. For making
  volume backups and restores.

Usage:

vackup export VOLUME FILE
  Creates a gzip'ed tarball in the current directory from a volume

vackup import FILE VOLUME
  Extracts a gzip'ed tarball into a volume

EOF
  ) || error "Failed to generate the usage text"

  if [ $STDERR -eq 1 ]; then
    echo 1>&2 "$TEXT"
  else
    echo 1>&3 "$TEXT"
  fi

  if [ $EXIT -eq 1 ]; then
    if [ $STDERR -eq 1 ]; then
      if [ $CALLER -eq 1 ]; then
        LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
        handle_error $LINE_NUMBER 1
      else
        exit 1
      fi
    else
      exit 0
    fi
  fi
}

warning() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      USAGE=1
      shift
    else
      USAGE=0
    fi

    case $# in
      0) MESSAGE='' ;;
      1) MESSAGE=$1 ;;
      *) MESSAGE=$1; warning 'Wrong number of arguments in the warning function' ;;
    esac

    if [ -n "$MESSAGE" ]; then
      MESSAGE=": $MESSAGE"
    fi
  else
    USAGE=0
    MESSAGE=''
  fi

  printf 1>&2 "${BOLD_YELLOW_COLOR_ERR}Warning${RESET_COLOR_ERR}${MESSAGE}\n"

  if [ $USAGE -eq 1 ]; then
    print_usage --err
  fi
}

error() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      USAGE=1
      shift
    else
      USAGE=0
    fi

    case $# in
      0) MESSAGE=''; CODE=1 ;;
      1) MESSAGE=$1; CODE=1 ;;
      2) MESSAGE=$1; CODE=$2 ;;
      *) MESSAGE=$1; CODE=$2; warning 'Wrong number of arguments in the error function' ;;
    esac

    if [ -n "$MESSAGE" ]; then
      MESSAGE=": $MESSAGE"
    fi
  else
    USAGE=0
    MESSAGE=''
    CODE=1
  fi

  printf 1>&2 "${BOLD_RED_COLOR_ERR}Error${RESET_COLOR_ERR}${MESSAGE}\n"

  if [ $USAGE -eq 1 ]; then
    print_usage --err
  fi

  if [ $CALLER -eq 1 ]; then
    LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
    handle_error $LINE_NUMBER $CODE
  else
    exit $CODE
  fi
}

information() {
  COLOR="$BLUE_COLOR"

  if [ $# -ne 0 ]; then
    case "$1" in
      --*)
        case "$1" in
          --no-color) COLOR="$RESET_COLOR" ;;
          --black) COLOR="$BLACK_COLOR" ;;
          --red) COLOR="$RED_COLOR" ;;
          --green) COLOR="$GREEN_COLOR" ;;
          --yellow) COLOR="$YELLOW_COLOR" ;;
          --blue) COLOR="$BLUE_COLOR" ;;
          --purple) COLOR="$PURPLE_COLOR" ;;
          --cyan) COLOR="$CYAN_COLOR" ;;
          --white) COLOR="$WHITE_COLOR" ;;
          *) warning 'unrecognized color' ;;
        esac

        shift
      ;;
      *) ;;
    esac
  fi

  case $# in
    1) MESSAGE=$1 ;;
    2) MESSAGE="${COLOR}$1${RESET_COLOR}: $2" ;;
    *) MESSAGE=$1; warning 'Wrong number of arguments in the information function' ;;
  esac

  printf "$MESSAGE\n"
}

chars() {
  case $# in
    1) STR="$1" ;;
    2)
      STR="$2"
      SKIP="$1"

      LEN="${#STR}"
      if [ $LEN -lt $SKIP ]; then
        SKIP="$LEN"
      fi

      while [ "$SKIP" -gt 0 ]; do
        STR="${STR#?}"
        SKIP=$((SKIP - 1))
      done
    ;;
    *) STR="$1"; warning 'Wrong number of arguments in the chars function' ;;
  esac

  while [ -n "$STR" ]; do
    REST="${STR#?}"

    CHAR="${STR%"$REST"}"
    echo "$CHAR"

    STR="$REST"
  done
}

prefix_all() {
  case $# in
    0 | 1) LIST=''; warning 'Wrong number of arguments in the prefix_all function' ;;
    *) PREFIX="$1"; shift; LIST="$@" ;;
  esac

  for ITEM in $LIST; do
    ITEM="$PREFIX$ITEM"
    printf '%s\n' "$ITEM"
  done
}

fulldirname() {
  DIRECTORY=$(dirname "$1") || error "Failed to get the parent directory for $1"

  case "$DIRECTORY" in
    /*) ;;
    *) DIRECTORY="$(pwd)/$DIRECTORY" ;;
  esac
  DIRECTORY=$(readlink -m "$DIRECTORY") || error "Failed to get the full path for $DIRECTORY"

  echo "$DIRECTORY"
}

assert_is_directory() {
  if [ $# -gt 0 ]; then
    DIRECTORY="$1"
  fi

  case "$DIRECTORY" in
    */) ;;
    *)
      if [ -f "$DIRECTORY" ]; then
        error "'$DIRECTORY' is a file"
      fi

      DIRECTORY="$DIRECTORY/"
    ;;
  esac
}

append_file_if_dir() {
  DIR_OR_FILE="$1"
  FILE="$2"

  case "$DIR_OR_FILE" in
    */) echo "$DIR_OR_FILE$FILE" ;;
    *)
      if [ -d "$DIR_OR_FILE" ]; then
        echo "$DIR_OR_FILE/$FILE"
      else
        echo "$DIR_OR_FILE"
      fi
    ;;
  esac
}

volume_doesnot_exists() {
  ERROR=0
  CREATE=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          --error) ERROR=1 ;;
          --create) CREATE=1 ;;
          *) warning "'$OPTION' is not a recognized volume_doesnot_exists option"
        esac
      ;;
      *) break ;;
    esac
  done

  if [ $# -gt 0 ]; then
    VOLUME_NAME="$1"
  fi

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    if [ $ERROR -eq 1 ]; then
      error "Volume $VOLUME_NAME does not exist"
    elif [ $CREATE -eq 1 ]; then
      warning "Volume $VOLUME_NAME does not exist, creating..."
      docker volume create "$VOLUME_NAME" 1> /dev/null || error "Failed to create volume $VOLUME_NAME"
    else
      warning "Volume $VOLUME_NAME does not exist"
    fi
  fi
}

get_volumes() {
  VOLUME_NAMES=$(docker volume ls -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of volumes'
}

get_volumes_in_use() {
  get_volumes

  VOLUMES=''
  for VOLUME_NAME in $VOLUME_NAMES; do
    CONTAINERS=$(docker ps -q -a -f volume="$VOLUME_NAME") || error "Failed to get the list of containers using volume $VOLUME_NAME"

    if [ -n "$CONTAINERS" ]; then
      if [ -z "$VOLUMES" ]; then
        VOLUMES="$VOLUME_NAME"
      else
        VOLUMES="$VOLUMES $VOLUME_NAME"
      fi
    fi
  done

  VOLUME_NAMES="$VOLUMES"
}

get_running_containers() {
  if [ $# -gt 0 ]; then
    VOLUME_NAME="$1"
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME" | tr '\n' ' ' | awk '{$1=$1;print}') || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
  else
    CONTAINERS=$(docker ps -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of running containers'
  fi
}

stop_containers() {
  if [ -n "$CONTAINERS" ]; then
    information 'Stopping containers' "$CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null || error 'Failed to stop containers'
  fi
}

restart_containers() {
  if [ -n "$CONTAINERS" ]; then
    information 'Restarting containers' "$CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null || error 'Failed to restart containers'
  fi
}

EXTENSION='tar.gz'

command_export() {
  PARENTS=0
  OVERWRITE=0
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -h | --help) print_usage --exit ;;
          -p | --parents) PARENTS=1 ;;
          -f | --force) OVERWRITE=1 ;;
          -s | --stop) STOP=1 ;;
          --*) error usage "'$OPTION' is not a recognized export option" ;;
          -??*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          *) error usage "'$OPTION' is not a recognized export option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="./" ;;
    2) VOLUME_NAME="$1"; FILE_NAME="$2" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  FILE_NAME=$(append_file_if_dir "$FILE_NAME" "$VOLUME_NAME.$EXTENSION")
  if [ -f "$FILE_NAME" ]; then
    if [ $OVERWRITE -eq 1 ]; then
      if [ ! -w "$FILE_NAME" ]; then
        error "Unable to write to '$FILE_NAME'"
      fi
    else
      error "File '$FILE_NAME' already exists"
    fi
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME") || error "Faile to get the full path for $FILE_NAME"
  FILE_NAME=$(basename "$FILE_NAME") || error "Failed to get the file name for $FILE_NAME"

  if [ $PARENTS -eq 1 ]; then
    if ! mkdir -p "$DIRECTORY"; then
      error "Failed to make parent directories for '$DIRECTORY/$FILE_NAME'"
    fi
  fi

  if [ ! -w "$DIRECTORY" ]; then
    error "Unable to write to '$DIRECTORY'"
  fi
  assert_is_directory

  volume_doesnot_exists --error

  if [ $STOP -eq 1 ]; then
    get_running_containers "$VOLUME_NAME"
  else
    CONTAINERS=''
  fi

  stop_containers

  TAR_OPTIONS='-zc'
  if [ $VERBOSE -eq 1 ]; then
    TAR_OPTIONS="${TAR_OPTIONS}v"
  fi
  TAR_OPTIONS="${TAR_OPTIONS}f"

  information 'Exporting volume' "$VOLUME_NAME"
  if [ $HOST -eq 1 ]; then
    MOUNTPOINT=$(docker inspect --format '{{ .Mountpoint }}' "$VOLUME_NAME") || {
      restart_containers
      error 'Failed to get the mountpoint'
    }

    if ! tar $TAR_OPTIONS "$DIRECTORY/$FILE_NAME" -C "$MOUNTPOINT" .; then
      restart_containers
      error 'Failed to tar the volume'
    fi
  else
    if ! docker run --rm \
      -v "$VOLUME_NAME":/vackup-volume:ro \
      -v "$DIRECTORY":/vackup \
      busybox \
      tar $TAR_OPTIONS /vackup/"$FILE_NAME" -C /vackup-volume .; then
      restart_containers
      error 'Failed to start busybox backup container'
    fi
  fi

  restart_containers

  information --green 'Success' "Volume $VOLUME_NAME tar'ed into file '$FILE_NAME'"
}

command_import() {
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -h | --help) print_usage --exit ;;
          -s | --stop) STOP=1 ;;
          --*) error usage "'$OPTION' is not a recognized import option" ;;
          -??*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          *) error usage "'$OPTION' is not a recognized import option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="./" ;;
    2) FILE_NAME="$1"; VOLUME_NAME="$2" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  FILE_NAME=$(append_file_if_dir "$FILE_NAME" "$VOLUME_NAME.$EXTENSION")
  if [ ! -r "$FILE_NAME" ]; then
    error "Could not find or open '$FILE_NAME'"
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME") || error "Faile to get the full path for $FILE_NAME"
  FILE_NAME=$(basename "$FILE_NAME") || error "Failed to get the file name for $FILE_NAME"
  assert_is_directory

  volume_doesnot_exists --create

  if [ $STOP -eq 1 ]; then
    get_running_containers "$VOLUME_NAME"
    stop_containers
  else
    CONTAINERS=''
  fi

  TAR_OPTIONS='-xz'
  if [ $VERBOSE -eq 1 ]; then
    TAR_OPTIONS="${TAR_OPTIONS}v"
  fi
  TAR_OPTIONS="${TAR_OPTIONS}f"

  information 'Importing volume' "$VOLUME_NAME"
  if [ $HOST -eq 1 ]; then
    MOUNTPOINT=$(docker inspect --format '{{ .Mountpoint }}' "$VOLUME_NAME") || {
      restart_containers
      error 'Failed to get the mountpoint'
    }

    if ! tar $TAR_OPTIONS "$DIRECTORY/$FILE_NAME" -C "$MOUNTPOINT"; then
      restart_containers
      error 'Failed to extract the tar archive into the volume'
    fi
  else
    if ! docker run --rm \
      -v "$VOLUME_NAME":/vackup-volume \
      -v "$DIRECTORY/$FILE_NAME":"/vackup/$FILE_NAME":ro \
      busybox \
      tar $TAR_OPTIONS /vackup/"$FILE_NAME" -C /vackup-volume; then
      restart_containers
      error 'Failed to start busybox backup container'
    fi
  fi

  restart_containers

  information --green 'Success' "Archive '$FILE_NAME' unpacked into volume $VOLUME_NAME"
}

command_all_export() {
  ARGS=''
  INUSE=0
  STOP=0

  while [ $# -ne 1 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -h | --help) print_usage --exit ;;
          -p | --parents) ARGS="$ARGS --parents" ;;
          -f | --force) ARGS="$ARGS --force" ;;
          -i | --in-use) INUSE=1 ;;
          -s | --stop) STOP=1 ;;
          --*) error usage "'$OPTION' is not a recognized export option" ;;
          -??*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          *) error usage "'$OPTION' is not a recognized export option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1"; assert_is_directory ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  if [ $INUSE -eq 1 ]; then
    get_volumes_in_use
  else
    get_volumes
  fi

  if [ $STOP -eq 1 ]; then
    get_running_containers
    stop_containers
  else
    CONTAINERS=''
  fi

  for VOLUME_NAME in $VOLUME_NAMES; do
    if ! (command_export $ARGS "$VOLUME_NAME" "$DIRECTORY"); then
      restart_containers
      error "Failed during $VOLUME_NAME volume export"
    fi
  done

  restart_containers

  information --green 'Success' "Volumes [$VOLUME_NAMES] tar'ed into archive files"
}

command_all_import() {
  ARGS=''
  STOP=0

  while [ $# -ne 1 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -h | --help) print_usage --exit ;;
          -s | --stop) STOP=1 ;;
          --*) error usage "'$OPTION' is not a recognized import option" ;;
          -??*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          *) error usage "'$OPTION' is not a recognized import option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1"; assert_is_directory ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  get_volumes

  if [ $STOP -eq 1 ]; then
    get_running_containers
    stop_containers
  else
    CONTAINERS=''
  fi

  SUCCESSFUL=''
  for VOLUME_NAME in $VOLUME_NAMES; do
    FILE_NAME="$DIRECTORY$VOLUME_NAME.$EXTENSION"

    if [ ! -f "$FILE_NAME" ]; then
      warning "'$FILE_NAME' was not found, skipping import of '$VOLUME_NAME' volume"
      continue
    fi

    if ! (command_import $ARGS "$FILE_NAME" "$VOLUME_NAME"); then
      restart_containers
      error "Failed during $VOLUME_NAME volume import"
    fi

    if [ -z "$SUCCESSFUL" ]; then
      SUCCESSFUL="$VOLUME_NAME"
    else
      SUCCESSFUL="$SUCCESSFUL $VOLUME_NAME"
    fi
  done

  restart_containers

  information --green 'Success' "Archives unpacked into volumes [$SUCCESSFUL]"
}

command_all() {
  while [ $# -gt 0 ]; do
    COMMAND="$1"
    shift

    case "$COMMAND" in
      -h | --help | help) print_usage --exit ;;
      --*) error usage "'$COMMAND' is not a recognized command" ;;
      -??*) set -- $(prefix_all - $(chars 1 "$COMMAND")) "$@" ;;
      export) command_all_export "$@"; exit 0 ;;
      import) command_all_import "$@"; exit 0 ;;
      all | *) error usage "'$COMMAND' is not a recognized command" ;;
    esac
  done

  print_usage --exit
}

exec 3>&1
VERBOSE=0
HOST=0

while [ $# -gt 0 ]; do
  COMMAND="$1"
  shift

  case "$COMMAND" in
    -h | --help | help) print_usage --exit ;;
    -q | --quiet) exec 3>&1 1>/dev/null ;;
    -v | --verbose) VERBOSE=1 ;;
    -H | --host) HOST=1 ;;
    --*) error usage "'$COMMAND' is not a recognized command" ;;
    -??*) set -- $(prefix_all - $(chars 1 "$COMMAND")) "$@" ;;
    export) command_export "$@"; exit 0 ;;
    import) command_import "$@"; exit 0 ;;
    all) command_all "$@"; exit 0 ;;
    *) error usage "'$COMMAND' is not a recognized command" ;;
  esac
done

print_usage --exit

exit 0
