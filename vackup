#!/usr/bin/env bash
# Docker Volume File Backup and Restore Tool
# Easily tar up a volume on a local (or remote) engine
# Inspired by CLIP from Lukasz Lach

if [ -z "$LINENO" ]; then
  LINENO='unknown'
fi

if command -v caller 1> /dev/null 2>&1; then
  CALLER=1
else
  CALLER=0
fi

if [ -z "$BASH" ]; then
  BASH=''
fi

if [ -z "$VACKUP_FAILURE_SCRIPT" ]; then
  VACKUP_FAILURE_SCRIPT=''
fi

if [ -n "$BASH" ]; then
  set -Eeuo pipefail
else
  set -eu
fi

handle_error() {
  case $# in
    1) LINE_NUMBER=$1; EXIT_CODE=$? ;;
    2) LINE_NUMBER=$1; EXIT_CODE=$2 ;;
    *) LINE_NUMBER=$LINENO; EXIT_CODE=1 ;;
  esac

  if [ -n "$VACKUP_FAILURE_SCRIPT" ]; then
    /usr/bin/env bash "$VACKUP_FAILURE_SCRIPT" "$LINE_NUMBER" $EXIT_CODE
  fi

  exit $EXIT_CODE
}

if [ -n "$BASH" ]; then
  trap 'handle_error $LINENO' ERR
else
  trap 'handle_error $LINENO $?' EXIT
fi

print_usage() {
  STDERR=0
  EXIT=0

  while [ $# -ne 0 ]; do
    case "$1" in
      --err) STDERR=1 ;;
      --exit) EXIT=1 ;;
    esac

    shift
  done

  TEXT=$(cat <<EOF

"Docker Volume Backup". Replicates image management commands for volumes.

export/import copies files between a host tarball and a volume. For making
  volume backups and restores.

Usage:

vackup export VOLUME FILE
  Creates a gzip'ed tarball in the current directory from a volume

vackup import FILE VOLUME
  Extracts a gzip'ed tarball into a volume

EOF
  ) || error "Failed to generate the usage text"

  if [ $STDERR -eq 1 ]; then
    echo 1>&2 "$TEXT"
  else
    echo 1>&3 "$TEXT"
  fi

  if [ $EXIT -eq 1 ]; then
    if [ $STDERR -eq 1 ]; then
      if [ $CALLER -eq 1 ]; then
        LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
        handle_error $LINE_NUMBER 1
      else
        exit 1
      fi
    else
      exit 0
    fi
  fi
}

warning() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      USAGE=1
      shift
    else
      USAGE=0
    fi

    case $# in
      0) MESSAGE='' ;;
      1) MESSAGE=$1 ;;
      *) warning 'Wrong number of arguments'; MESSAGE=$1 ;;
    esac
  else
    USAGE=0
    MESSAGE=''
  fi

  if [ -z "$MESSAGE" ]; then
    echo 1>&2 'Warning'
  else
    echo 1>&2 "Warning: $MESSAGE"
  fi

  if [ $USAGE -eq 1 ]; then
    print_usage --err
  fi
}

error() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      USAGE=1
      shift
    else
      USAGE=0
    fi

    case $# in
      0) MESSAGE=''; CODE=1 ;;
      1) MESSAGE=$1; CODE=1 ;;
      2) MESSAGE=$1; CODE=$2 ;;
      *) warning 'Wrong number of arguments'; MESSAGE=$1; CODE=$2 ;;
    esac
  else
    USAGE=0
    MESSAGE=''
    CODE=1
  fi

  if [ -z "$MESSAGE" ]; then
    echo 1>&2 'Error'
  else
    echo 1>&2 "Error: $MESSAGE"
  fi

  if [ $USAGE -eq 1 ]; then
    print_usage --err
  fi

  if [ $CALLER -eq 1 ]; then
    LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
    handle_error $LINE_NUMBER $CODE
  else
    exit $CODE
  fi
}

fulldirname() {
  DIRECTORY=$(dirname "$1") || error "Failed to get the parent directory for $1"

  case "$DIRECTORY" in
    /*) ;;
    .*) DIRECTORY="$(pwd)/$DIRECTORY" ;;
    *) DIRECTORY="$(pwd)/$DIRECTORY" ;;
  esac
  DIRECTORY=$(readlink -m "$DIRECTORY") || error "Failed to get the full path for $DIRECTORY"

  echo "$DIRECTORY"
}

command_export() {
  PARENTS=0
  OVERWRITE=0
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        case "$1" in
          -h) print_usage --exit ;;
          --help) print_usage --exit ;;
          -p) PARENTS=1 ;;
          --parents) PARENTS=1 ;;
          -f) OVERWRITE=1 ;;
          --force) OVERWRITE=1 ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized export option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="$VOLUME_NAME.tar.gz" ;;
    2) VOLUME_NAME="$1"; FILE_NAME="$2" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$FILE_NAME" in
    */) FILE_NAME="$FILE_NAME$VOLUME_NAME.tar.gz" ;;
    *)
      if [ -d "$FILE_NAME" ]; then
        FILE_NAME="$FILE_NAME/$VOLUME_NAME.tar.gz"
      fi
    ;;
  esac

  if [ -f "$FILE_NAME" ]; then
    if [ $OVERWRITE -eq 1 ]; then
      if [ ! -w "$FILE_NAME" ]; then
        error "Unable to write to '$FILE_NAME'"
      fi
    else
      error "File '$FILE_NAME' already exists"
    fi
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME") || error "Faile to get the full path for $FILE_NAME"
  FILE_NAME=$(basename "$FILE_NAME") || error "Failed to get the file name for $FILE_NAME"

  if [ $PARENTS -eq 1 ]; then
    if ! mkdir -p "$DIRECTORY"; then
      error "Failed to make parent directories for '$DIRECTORY/$FILE_NAME'"
    fi
  fi

  if [ ! -w "$DIRECTORY" ]; then
    error "Unable to write to '$DIRECTORY'"
  fi

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    error "Volume $VOLUME_NAME does not exist"
  fi

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME") || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Stopping containers: $CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi

  echo "Exporting volume: $VOLUME_NAME"
  if ! docker run --rm \
    -v "$VOLUME_NAME":/vackup-volume:ro \
    -v "$DIRECTORY":/vackup \
    busybox \
    tar -zcvf /vackup/"$FILE_NAME" -C /vackup-volume .; then
    if [ -n "$CONTAINERS" ]; then
      echo "Restarting containers: $CONTAINERS"
      docker restart $CONTAINERS 1> /dev/null
    fi

    error 'Failed to start busybox backup container'
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Restarting containers: $CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null
  fi

  echo "Successfully tar'ed volume $VOLUME_NAME into file '$FILE_NAME'"
}

command_import() {
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        case "$1" in
          -h) print_usage --exit ;;
          --help) print_usage --exit ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized import option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="$VOLUME_NAME.tar.gz" ;;
    2) FILE_NAME="$1"; VOLUME_NAME="$2" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$FILE_NAME" in
    */) FILE_NAME="$FILE_NAME$VOLUME_NAME.tar.gz" ;;
    *)
      if [ -d "$FILE_NAME" ]; then
        FILE_NAME="$FILE_NAME/$VOLUME_NAME.tar.gz"
      fi
    ;;
  esac

  if [ ! -r "$FILE_NAME" ]; then
    error "Could not find or open '$FILE_NAME'"
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME") || error "Faile to get the full path for $FILE_NAME"
  FILE_NAME=$(basename "$FILE_NAME") || error "Failed to get the file name for $FILE_NAME"

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    warning "Volume $VOLUME_NAME does not exist, creating..."
    docker volume create "$VOLUME_NAME" 1> /dev/null
  fi

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME") || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Stopping containers: $CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi

  echo "Importing volume: $VOLUME_NAME"
  if ! docker run --rm \
    -v "$VOLUME_NAME":/vackup-volume \
    -v "$DIRECTORY/$FILE_NAME":"/vackup/$FILE_NAME":ro \
    busybox \
    tar -xvzf /vackup/"$FILE_NAME" -C /vackup-volume; then
    if [ -n "$CONTAINERS" ]; then
      echo "Restarting containers: $CONTAINERS"
      docker restart $CONTAINERS 1> /dev/null
    fi

    error 'Failed to start busybox backup container'
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Restarting containers: $CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null
  fi

  echo "Successfully unpacked '$FILE_NAME' into volume $VOLUME_NAME"
}

command_all_export() {
  ARGS=''
  STOP=0

  while [ $# -ne 1 ]; do
    case "$1" in
      -*)
        case "$1" in
          -h) print_usage --exit ;;
          --help) print_usage --exit ;;
          -p) ARGS="$ARGS -p" ;;
          --parents) ARGS="$ARGS --parents" ;;
          -f) ARGS="$ARGS -f" ;;
          --force) ARGS="$ARGS --force" ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized export option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$DIRECTORY" in
    */) ;;
    *)
      if [ -f "$DIRECTORY" ]; then
        error "'$DIRECTORY' is a file"
      fi

      DIRECTORY="$DIRECTORY/"
    ;;
  esac

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q) || error 'Failed to get the list of running containers'
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Stopping containers: $CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi

  VOLUME_NAMES=$(docker volume ls -q) || error 'Failed to get the list of volumes'

  FAILED=''
  for VOLUME_NAME in $VOLUME_NAMES; do
    if ! (command_export $ARGS "$VOLUME_NAME" "$DIRECTORY"); then
      FAILED="$VOLUME_NAME"
      break
    fi
  done

  if [ -n "$CONTAINERS" ]; then
    echo "Restarting containers: $CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null
  fi

  if [ -n "$FAILED" ]; then
    error "Failed during $FAILED volume export"
  fi

  echo "Successfully tar'ed volumes [$VOLUME_NAMES] into archive files"
}

command_all_import() {
  ARGS=''
  STOP=0

  while [ $# -ne 1 ]; do
    case "$1" in
      -*)
        case "$1" in
          -h) print_usage --exit ;;
          --help) print_usage --exit ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized export option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$DIRECTORY" in
    */) ;;
    *)
      if [ -f "$DIRECTORY" ]; then
        error "'$DIRECTORY' is a file"
      fi

      DIRECTORY="$DIRECTORY/"
    ;;
  esac

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q) || error 'Failed to get the list of running containers'
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Stopping containers: $CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi

  VOLUME_NAMES=$(docker volume ls -q) || error 'Failed to get the list of volumes'

  SUCCESSFUL=''
  FAILED=''
  for VOLUME_NAME in $VOLUME_NAMES; do
    FILE_NAME="$DIRECTORY$VOLUME_NAME.tar.gz"

    if [ ! -f "$FILE_NAME" ]; then
      warning "'$FILE_NAME' was not found, skipping import of '$VOLUME_NAME' volume"
      continue
    fi

    if ! (command_import $ARGS "$FILE_NAME" "$VOLUME_NAME"); then
      FAILED="$VOLUME_NAME"
      break
    fi

    SUCCESSFUL="$SUCCESSFUL $VOLUME_NAME"
  done

  if [ -n "$CONTAINERS" ]; then
    echo "Restarting containers: $CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null
  fi

  if [ -n "$FAILED" ]; then
    error "Failed during $FAILED volume import"
  fi

  echo "Successfully unpacked archies into volumes [$SUCCESSFUL]"
}

command_all() {
  if [ $# -eq 0 ]; then
    print_usage --exit
  fi

  COMMAND="$1"
  shift
  case "$COMMAND" in
    -h) print_usage --exit ;;
    --help) print_usage --exit ;;
    help) print_usage --exit ;;
    export) command_all_export "$@" ;;
    import) command_all_import "$@" ;;
    all) error usage "'$COMMAND' is not a recognized command" ;;
    *) error usage "'$COMMAND' is not a recognized command" ;;
  esac
}

exec 3>&1

parse_command() {
  if [ $# -eq 0 ]; then
    print_usage --exit
  fi

  COMMAND="$1"
  shift
  case "$COMMAND" in
    -h) print_usage --exit ;;
    --help) print_usage --exit ;;
    help) print_usage --exit ;;
    -q) exec 3>&1 1>/dev/null; parse_command "$@" ;;
    --quiet) exec 3>&1 1>/dev/null; parse_command "$@" ;;
    export) command_export "$@" ;;
    import) command_import "$@" ;;
    all) command_all "$@" ;;
    *) error usage "'$COMMAND' is not a recognized command" ;;
  esac
}

parse_command "$@"

exit 0
