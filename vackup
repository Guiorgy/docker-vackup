#!/bin/bash
# Docker Volume File Backup and Restore Tool
# Easily tar up a volume on a local (or remote) engine
# Inspired by CLIP from Lukasz Lach

set -Eeo pipefail

handle_error() {
  case $# in
    1) LINE_NUMBER=$1; EXIT_CODE=$? ;;
    2) LINE_NUMBER=$1; EXIT_CODE=$2 ;;
    *) LINE_NUMBER=$LINENO; EXIT_CODE=1 ;;
  esac

  if [ -n "${VACKUP_FAILURE_SCRIPT}" ]; then
    /bin/bash "${VACKUP_FAILURE_SCRIPT}" "$LINE_NUMBER" $EXIT_CODE
  fi

  exit $EXIT_CODE
}

trap 'handle_error $LINENO' ERR

print_usage() {
  TEXT=$(cat <<EOF

"Docker Volume Backup". Replicates image management commands for volumes.

export/import copies files between a host tarball and a volume. For making
  volume backups and restores.

Usage:

vackup export VOLUME FILE
  Creates a gzip'ed tarball in the current directory from a volume

vackup import FILE VOLUME
  Extracts a gzip'ed tarball into a volume

EOF
  )

  case $1 in
    -e) echo 1>&2 "$TEXT"; shift ;;
    --err) echo 1>&2 "$TEXT"; shift ;;
    *) echo 1>&3 "$TEXT" ;;
  esac

  if [ $# -ne 0 ]; then
    if [ "$1" = '0' ]; then
      exit 0
    else
      LINE_NUMBER=$(caller | awk '{ print $1 }')
      handle_error $LINE_NUMBER $1
    fi
  fi
}

error() {
  if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
    USAGE=1
    MESSAGE=$2
    CODE=$3
  else
    USAGE=0
    MESSAGE=$1
    CODE=$2
  fi

  if [ -z "$MESSAGE" ]; then
    echo 1>&2 'Error'
  else
    echo 1>&2 "Error: $MESSAGE"
  fi

  if [ $USAGE -eq 1 ]; then
    print_usage --err
  fi

  if [ -z "$CODE" ]; then
    CODE=1
  fi

  LINE_NUMBER=$(caller | awk '{ print $1 }')
  handle_error $LINE_NUMBER $CODE
}

warning() {
  if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
    USAGE=1
    MESSAGE=$2
  else
    USAGE=0
    MESSAGE=$1
  fi

  if [ -z "$MESSAGE" ]; then
    echo 1>&2 'Warning'
  else
    echo 1>&2 "Warning: $MESSAGE"
  fi

  if [ $USAGE -eq 1 ]; then
    print_usage --err
  fi
}

fulldirname() {
  DIRECTORY=$(dirname "$1")

  case "$DIRECTORY" in
    /*) ;;
    .*) DIRECTORY="$(pwd)/$DIRECTORY" ;;
    *) DIRECTORY="$(pwd)/$DIRECTORY" ;;
  esac
  DIRECTORY=$(readlink -m "$DIRECTORY")

  echo "$DIRECTORY"
}

command_export() {
  PARENTS=0
  OVERWRITE=0
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        case "$1" in
          -p) PARENTS=1 ;;
          --parents) PARENTS=1 ;;
          -f) OVERWRITE=1 ;;
          --force) OVERWRITE=1 ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized export option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="$VOLUME_NAME.tar.gz" ;;
    2) VOLUME_NAME="$1"; FILE_NAME="$2" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$FILE_NAME" in
    */) FILE_NAME="$FILE_NAME$VOLUME_NAME.tar.gz" ;;
    *)
      if [ -d "$FILE_NAME" ]; then
        FILE_NAME="$FILE_NAME/$VOLUME_NAME.tar.gz"
      fi
    ;;
  esac

  if [ -f "$FILE_NAME" ]; then
    if [ $OVERWRITE -eq 1 ]; then
      if [ ! -w "$FILE_NAME" ]; then
        error "Unable to write to '$FILE_NAME'"
      fi
    else
      error "File '$FILE_NAME' already exists"
    fi
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME")
  FILE_NAME=$(basename "$FILE_NAME")

  if [ $PARENTS -eq 1 ]; then
    if ! mkdir -p "$DIRECTORY"; then
      error "Failed to make parent directories for '$DIRECTORY/$FILE_NAME'"
    fi
  fi

  if [ ! -w "$DIRECTORY" ]; then
    error "Unable to write to '$DIRECTORY'"
  fi

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    error "Volume $VOLUME_NAME does not exist"
  fi

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME")
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Stopping containers: $CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi

  echo "Exporting volume: $VOLUME_NAME"
  if ! docker run --rm \
    -v "$VOLUME_NAME":/vackup-volume \
    -v "$DIRECTORY":/vackup \
    busybox \
    tar -zcvf /vackup/"$FILE_NAME" -C /vackup-volume .; then
    if [ -n "$CONTAINERS" ]; then
      echo "Restarting containers: $CONTAINERS"
      docker restart $CONTAINERS 1> /dev/null
    fi

    error 'Failed to start busybox backup container'
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Restarting containers: $CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null
  fi

  echo "Successfully tar'ed volume $VOLUME_NAME into file '$FILE_NAME'"
}

command_import() {
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        case "$1" in
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized import option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="$VOLUME_NAME.tar.gz" ;;
    2) FILE_NAME="$1"; VOLUME_NAME="$2" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$FILE_NAME" in
    */) FILE_NAME="$FILE_NAME$VOLUME_NAME.tar.gz" ;;
    *)
      if [ -d "$FILE_NAME" ]; then
        FILE_NAME="$FILE_NAME/$VOLUME_NAME.tar.gz"
      fi
    ;;
  esac

  if [ ! -r "$FILE_NAME" ]; then
    error "Could not find or open '$FILE_NAME'"
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME")
  FILE_NAME=$(basename "$FILE_NAME")

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    warning "Volume $VOLUME_NAME does not exist, creating..."
    docker volume create "$VOLUME_NAME" 1> /dev/null
  fi

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME")
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Stopping containers: $CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi

  echo "Importing volume: $VOLUME_NAME"
  if ! docker run --rm \
    -v "$VOLUME_NAME":/vackup-volume \
    -v "$DIRECTORY":/vackup \
    busybox \
    tar -xvzf /vackup/"$FILE_NAME" -C /vackup-volume; then
    if [ -n "$CONTAINERS" ]; then
      echo "Restarting containers: $CONTAINERS"
      docker restart $CONTAINERS 1> /dev/null
    fi

    error 'Failed to start busybox backup container'
  fi

  if [ -n "$CONTAINERS" ]; then
    echo "Restarting containers: $CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null
  fi

  echo "Successfully unpacked '$FILE_NAME' into volume $VOLUME_NAME"
}

exec 3>&1

parse_command() {
  if [ $# -eq 0 ]; then
    print_usage 0
  fi

  COMMAND="$1"
  shift
  case "$COMMAND" in
    -h) print_usage 0 ;;
    --help) print_usage 0 ;;
    help) print_usage 0 ;;
    -q) exec 3>&1 1>/dev/null; parse_command "$@" ;;
    --quiet) exec 3>&1 1>/dev/null; parse_command "$@" ;;
    export) command_export "$@" ;;
    import) command_import "$@" ;;
    *) error usage "'$COMMAND' is not a recognized command" ;;
  esac
}

parse_command "$@"

exit 0
