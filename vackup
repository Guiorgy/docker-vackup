#!/usr/bin/env bash

# Docker Volume File Backup and Restore Tool
# Easily tar up a volume on a local (or remote) engine
# Base on vackup by Bret Fisher
# Inspired by CLIP from Lukasz Lach
#
# This script targets bash for better error handling, which isn't required
# It checks the BASH variable, and falls back to POSIX compliance if not set
# It (hopefully) works with any POSIX shell

# The file name of the script in case it was renamed
VACKUP=$(basename "$0")

# Some shells don't support this (looking at you dash)
if [ -z "$LINENO" ]; then
  LINENO='unknown'
fi

# Silently check if the caller command is defined
if command -v caller 1> /dev/null 2>&1; then
  CALLER=1
else
  CALLER=0
fi

# Check if we are in bash
if [ -z "$BASH" ]; then
  BASH=''
fi

# Define VACKUP_FAILURE_SHELL and VACKUP_FAILURE_SCRIPT if not defined
if [ -z "$VACKUP_FAILURE_SHELL" ]; then
  VACKUP_FAILURE_SHELL=''
fi
if [ -z "$VACKUP_FAILURE_SCRIPT" ]; then
  VACKUP_FAILURE_SCRIPT=''
fi

# Modify shell behavior
if [ -n "$BASH" ]; then
  # -E: The trap on ERR is inherited by shell functions, command substitutions, and commands executed in a subshell environment
  # -e: Exit immediately if a pipeline returns a non-zero status
  # -u: The shell shall write a message to standard error when it tries to expand a variable that is not set and immediately exit
  # -o pipefail: The return value of a pipeline is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands in the pipeline exit successfully
  set -Eeuo pipefail
else
  set -eu
fi

# Executes the VACKUP_FAILURE_SCRIPT script with line number and error code as arguments using the VACKUP_FAILURE_SHELL shell and exit
# Remark: Line number may be 'unknown' on some shells, e.g. dash
# Executed when an error is trapped, or the error function is called
# Parameters:
#   LineNumber (required): The line number of the failed command
#   ExitCode: The error code of the failed command
handle_error() {
  case $# in
    1) LINE_NUMBER=$1; EXIT_CODE=$? ;;
    2) LINE_NUMBER=$1; EXIT_CODE=$2 ;;
    *) LINE_NUMBER=$LINENO; EXIT_CODE=1 ;;
  esac

  if [ -n "$VACKUP_FAILURE_SCRIPT" ]; then
    if [ -z "$VACKUP_FAILURE_SHELL" ]; then
      if [ -n "$BASH" ]; then
        VACKUP_FAILURE_SHELL="$BASH"
      else
        VACKUP_FAILURE_SHELL=$(command -v sh 2> /dev/null) || 'sh'
      fi
    fi

    "$VACKUP_FAILURE_SHELL" "$VACKUP_FAILURE_SCRIPT" "$LINE_NUMBER" "$EXIT_CODE"
  fi

  exit "$EXIT_CODE"
}

# Set up a trap
if [ -n "$BASH" ]; then
  trap 'handle_error $LINENO' ERR
else
  trap 'handle_error $LINENO $?' EXIT
fi

# Initialize colors for STDOUT if it's connected to a tty
if [ -t 1 ]; then
  RESET_COLOR='\033[0m'

  BLACK_COLOR='\033[0;30m'
  RED_COLOR='\033[0;31m'
  GREEN_COLOR='\033[0;32m'
  YELLOW_COLOR='\033[0;33m'
  BLUE_COLOR='\033[0;34m'
  PURPLE_COLOR='\033[0;35m'
  CYAN_COLOR='\033[0;36m'
  WHITE_COLOR='\033[0;37m'

  BOLD_BLACK_COLOR='\033[1;30m'
  BOLD_RED_COLOR='\033[1;31m'
  BOLD_GREEN_COLOR='\033[1;32m'
  BOLD_YELLOW_COLOR='\033[1;33m'
  BOLD_BLUE_COLOR='\033[1;34m'
  BOLD_PURPLE_COLOR='\033[1;35m'
  BOLD_CYAN_COLOR='\033[1;36m'
  BOLD_WHITE_COLOR='\033[1;37m'
else
  RESET_COLOR=''

  BLACK_COLOR=''
  RED_COLOR=''
  GREEN_COLOR=''
  YELLOW_COLOR=''
  BLUE_COLOR=''
  PURPLE_COLOR=''
  CYAN_COLOR=''
  WHITE_COLOR=''

  BOLD_BLACK_COLOR=''
  BOLD_RED_COLOR=''
  BOLD_GREEN_COLOR=''
  BOLD_YELLOW_COLOR=''
  BOLD_BLUE_COLOR=''
  BOLD_PURPLE_COLOR=''
  BOLD_CYAN_COLOR=''
  BOLD_WHITE_COLOR=''
fi

# Initialize colors for STDERR if it's connected to a tty
if [ -t 2 ]; then
  RESET_COLOR_ERR='\033[0m'

  BLACK_COLOR_ERR='\033[0;30m'
  RED_COLOR_ERR='\033[0;31m'
  GREEN_COLOR_ERR='\033[0;32m'
  YELLOW_COLOR_ERR='\033[0;33m'
  BLUE_COLOR_ERR='\033[0;34m'
  PURPLE_COLOR_ERR='\033[0;35m'
  CYAN_COLOR_ERR='\033[0;36m'
  WHITE_COLOR_ERR='\033[0;37m'

  BOLD_BLACK_COLOR_ERR='\033[1;30m'
  BOLD_RED_COLOR_ERR='\033[1;31m'
  BOLD_GREEN_COLOR_ERR='\033[1;32m'
  BOLD_YELLOW_COLOR_ERR='\033[1;33m'
  BOLD_BLUE_COLOR_ERR='\033[1;34m'
  BOLD_PURPLE_COLOR_ERR='\033[1;35m'
  BOLD_CYAN_COLOR_ERR='\033[1;36m'
  BOLD_WHITE_COLOR_ERR='\033[1;37m'
else
  RESET_COLOR_ERR=''

  BLACK_COLOR_ERR=''
  RED_COLOR_ERR=''
  GREEN_COLOR_ERR=''
  YELLOW_COLOR_ERR=''
  BLUE_COLOR_ERR=''
  PURPLE_COLOR_ERR=''
  CYAN_COLOR_ERR=''
  WHITE_COLOR_ERR=''

  BOLD_BLACK_COLOR_ERR=''
  BOLD_RED_COLOR_ERR=''
  BOLD_GREEN_COLOR_ERR=''
  BOLD_YELLOW_COLOR_ERR=''
  BOLD_BLUE_COLOR_ERR=''
  BOLD_PURPLE_COLOR_ERR=''
  BOLD_CYAN_COLOR_ERR=''
  BOLD_WHITE_COLOR_ERR=''
fi

# The default extension of the exported/imported archive
EXTENSION='.tar.gz'

# Prints usage and exits if necessary
# Flags:
#   --err: Print to STDERR instead of STDOUT
#   --exit: Exit after printing usage.
#           If --err is also set, exit with the error code 1
# Parameters:
#   For (optional, main by default): One of main, export, import, all, export-all or import-all
print_usage() {
  STDERR=0
  EXIT=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          --err) STDERR=1 ;;
          --exit) EXIT=1 ;;
          *) warning "'$OPTION' is not a recognized print_usage option"
        esac
      ;;
      *) break ;;
    esac
  done

  if [ $# -eq 0 ]; then
    FOR='main'
  else
    FOR="$1"

    if [ $# -gt 1 ]; then
      warning 'Wrong number of arguments in the print_usage function'
    fi
  fi

  case "$FOR" in
    main)
      TEXT=$(cat <<EOF

Usage: $VACKUP [OPTIONS] COMMAND

"Docker Volume Backup". Replicates image management commands for volumes.

Commands:
  help        Print this help page
  export      Export a docker volume into an archive file
  import      Import a docker volume from an archive file
  all         Export/import multiple docker volumes to/from archive files

Options:
  -h, --help        Print this help page
  -q, --quiet       Silence the outputs to STDOUT, except if the help page is
                    explicitly requested
  -v, --verbose     Verbose printing
  -H, --host        Do the export/import by running the archive program on the
                    host instead of a container

Run '$VACKUP COMMAND --help' for more information on a command.

EOF
      ) || error "Failed to generate the usage text"
    ;;
    export)
      TEXT=$(cat <<EOF

Usage: $VACKUP export [OPTIONS] VOLUME_NAME [OUTPUT]

Export a docker volume into an archive file

Parameters:
  VOLUME_NAME     The docker volume to export
  OUTPUT          The path to the output archive file. If the path points to a
                  directory, a file inside the said directory with the name of
                  the volume and archive extension will be assumed

Options:
  -h, --help        Print this help page
  -p, --parents     Create parent directories for the archive file as needed
  -f, --force       Overwrite the archive file if a file already exists
  -s, --stop        Stop running containers that have the specified volume as a
                    mount point before exporting, and restart them after

EOF
      ) || error "Failed to generate the usage text"
    ;;
    import)
      TEXT=$(cat <<EOF

Usage:
  $VACKUP import [OPTIONS] INPUT VOLUME_NAME
  $VACKUP import [OPTIONS] VOLUME_NAME

Import a docker volume from an archive file

Parameters:
  INPUT           The path to the intput archive file. If the path points to a
                  directory, a file inside the said directory with the name of
                  the volume and archive extension will be assumed
  VOLUME_NAME     The docker volume to import

Options:
  -h, --help      Print this help page
  -s, --stop      Stop running containers that have the specified volume as a
                  mount point before importing, and restart them after

EOF
      ) || error "Failed to generate the usage text"
    ;;
    all)
      TEXT=$(cat <<EOF

Usage: $VACKUP all [OPTIONS] COMMAND

Export/import multiple docker volumes to/from archive files

Commands:
  help        Print this help page
  export      Export multiple docker volumes into archive files
  import      Import multiple docker volumes from archive files

Options:
  -h, --help      Print this help page

Run '$VACKUP all COMMAND --help' for more information on a command.

EOF
      ) || error "Failed to generate the usage text"
    ;;
    export-all)
      TEXT=$(cat <<EOF

Usage: $VACKUP all export [OPTIONS] OUTPUT

Export multiple docker volumes into archive files
All exported archives will be named as the name of the volume and archive
extension, e.g. my_docker_volume$EXTENSION

Parameters:
  OUTPUT      The path to the output directory where the archive files will be
              exported to

Options:
  -h, --help              Print this help page
  -p, --parents           Create parent directories for the archive files as
                          needed
  -f, --force             Overwrite the archive files if a file already exists
  -i, --in-use            Only export volumes that are in use by at least one
                          container
  -s, --stop              Stop the running containers that mount a volume
                          before exporting, and restart them after. Takes
                          priority over the -S, --stop-all flag
  -S, --stop-all          Stop all running containers before exporting, and
                          restart them after
  --exclude-containers=CONTAINERS
                          Exclude the specified containers from being
                          stopped, where CONTAINERS is a comma separated list
                          of container names. This option is valid only in
                          conjunction with either --stop or --stop_all
  --exclude-volumes=VOLUMES
                          Exlcude the specified volumes from being exported,
                          where VOLUMES is a comma separated list of volume
                          names
  -d, --date              Add the current date in the yyyy-MM-dd_HH-mm-ss
                          ISOish format to the start of the archive file names.
                          If the flag is passed in a second time, append the
                          date to the end of the archive file names instead.
                          Mutually exclusive with the -D, --date-dir flag
  -D, --date-dir          Use the current date in the yyyy-MM-dd_HH-mm-ss
                          ISOish format as the output directory where the
                          archive files will be exported to. This directory
                          will be created inside the directory defined with the
                          OUTPUT parameter. If the flag is passed in a second
                          time, append the date to the start of the OUTPUT
                          directory name, instead of creating a new directory
                          inside the OUTPUT directory. If the flag is passed in
                          a third time, append the date to the end of the
                          OUTPUT directory name instead. Mutually exclusive
                          with the -d, --date flag
  -u, --utc               Use UTC instead of the local timezone. This option is
                          valid only in conjunction with either --date or
                          --date-dir
  -k, --keep=N            Keep the most recent N exported directories/archives,
                          and remove older ones. This option is valid only in
                          conjunction with either --date or --date-dir.
                          Mutually exclusive with the -K, --keep-days option
  -K, --keep-days=DAYS    Remove exported directories/archives older than DAYS
                          days. This option is valid only in conjunction with
                          either --date or --date-dir. Mutually exclusive with
                          the -k, --keep option

EOF
      ) || error "Failed to generate the usage text"
    ;;
    import-all)
      TEXT=$(cat <<EOF

Usage: $VACKUP all import [OPTIONS] INPUT

Import multiple docker volumes from archive files
All imported archives will be assumed to be named as the name of the volume and
archive extension, e.g. my_docker_volume$EXTENSION

Parameters:
  INPUT           The path to the intput directory where all the archive files
                  to be imported are

Options:
  -h, --help              Print this help page
  -s, --stop              Stop the running containers that mount a volume
                          before importing, and restart them after. Takes
                          priority over the -S, --stop-all flag
  -S, --stop-all          Stop all running containers before importing, and
                          restart them after
  --exclude-containers=CONTAINERS
                          Exclude the specified containers from being
                          stopped, where CONTAINERS is a comma separated list
                          of container names. This option is valid only in
                          conjunction with either --stop or --stop_all
  --exclude-volumes=VOLUMES
                          Exlcude the specified volumes from being imported,
                          where VOLUMES is a comma separated list of volume
                          names

EOF
      ) || error "Failed to generate the usage text"
    ;;
    *)
      warning "'$FOR' is not a recognized print_usage target"

      if [ $STDERR -eq 1 ]; then
        print_usage --err
      else
        print_usage
      fi

      TEXT=''
    ;;
  esac

  if [ $STDERR -eq 1 ]; then
    echo 1>&2 "$TEXT"
  else
    echo 1>&3 "$TEXT"
  fi

  if [ $EXIT -eq 1 ]; then
    if [ $STDERR -eq 1 ]; then
      if [ $CALLER -eq 1 ]; then
        LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
        handle_error "$LINE_NUMBER" 1
      else
        exit 1
      fi
    else
      exit 0
    fi
  fi
}

# Prints a warning message to STDERR in yellow
# Options:
#   {u|usage} Target: Print usage for the specified target to STDERR after printing the warning message
# Parameters:
#   Message (optional, empty by default): The message to print
warning() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      shift

      if [ $# -gt 0 ]; then
        USAGE="$1"
      else
        USAGE='main'
        warning 'Wrong number of arguments in the warning function'
      fi

      shift
    else
      USAGE=''
    fi

    case $# in
      0) MESSAGE='' ;;
      1) MESSAGE=$1 ;;
      *) MESSAGE=$1; warning 'Wrong number of arguments in the warning function' ;;
    esac

    if [ -n "$MESSAGE" ]; then
      MESSAGE=": $MESSAGE"
    fi
  else
    USAGE=''
    MESSAGE=''
  fi

  printf 1>&2 '%b' "${BOLD_YELLOW_COLOR_ERR}Warning${RESET_COLOR_ERR}${MESSAGE}\n"

  if [ -n "$USAGE" ]; then
    print_usage --err "$USAGE"
  fi
}

# Prints an error message to STDERR in red and exits
# Options:
#   {u|usage} Target: Print usage for the specified target to STDERR after printing the error message
# Parameters:
#   Message (optional, empty by default): The message to print
#   ErrorCode (optional, 1 by default): The error code to exit with
error() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      shift

      if [ $# -gt 0 ]; then
        USAGE="$1"
      else
        USAGE='main'
        warning 'Wrong number of arguments in the error function'
      fi

      shift
    else
      USAGE=''
    fi

    case $# in
      0) MESSAGE=''; CODE=1 ;;
      1) MESSAGE=$1; CODE=1 ;;
      2) MESSAGE=$1; CODE=$2 ;;
      *) MESSAGE=$1; CODE=$2; warning 'Wrong number of arguments in the error function' ;;
    esac

    if [ -n "$MESSAGE" ]; then
      MESSAGE=": $MESSAGE"
    fi
  else
    USAGE=''
    MESSAGE=''
    CODE=1
  fi

  printf 1>&2 '%b' "${BOLD_RED_COLOR_ERR}Error${RESET_COLOR_ERR}${MESSAGE}\n"

  if [ -n "$USAGE" ]; then
    print_usage --err "$USAGE"
  fi

  if [ $CALLER -eq 1 ]; then
    LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
    handle_error "$LINE_NUMBER" "$CODE"
  else
    exit "$CODE"
  fi
}

# Prints an information message to STDOUT in the specified color
# Flags:
#   --{no-color,black,red,green,yellow,blue,purple,cyan,white} (--blue by default): The color of the output
# Parameters:
#   Message (optional, empty by default): The message to print
information() {
  COLOR="$BLUE_COLOR"

  if [ $# -ne 0 ]; then
    case "$1" in
      --*)
        case "$1" in
          --no-color) COLOR="$RESET_COLOR" ;;
          --black) COLOR="$BLACK_COLOR" ;;
          --red) COLOR="$RED_COLOR" ;;
          --green) COLOR="$GREEN_COLOR" ;;
          --yellow) COLOR="$YELLOW_COLOR" ;;
          --blue) COLOR="$BLUE_COLOR" ;;
          --purple) COLOR="$PURPLE_COLOR" ;;
          --cyan) COLOR="$CYAN_COLOR" ;;
          --white) COLOR="$WHITE_COLOR" ;;
          *) warning "'$1' is an unrecognized color option in the information function" ;;
        esac

        shift
      ;;
      *) ;;
    esac
  fi

  case $# in
    1) MESSAGE=$1 ;;
    2) MESSAGE="${COLOR}$1${RESET_COLOR}: $2" ;;
    *) MESSAGE=$1; warning 'Wrong number of arguments in the information function' ;;
  esac

  printf '%b' "$MESSAGE\n"
}

# Silently check if the tac command is defined, and define it if it doesn't
if ! command -v tac 1> /dev/null 2>&1; then
  # Reverses the order of lines
  tac() {
    sed '1!G;h;$!d'
  }
fi

# Splits a string into individual characters, skipping the specified number of characters from the start
# Remark: Iterating over the resulting sequence using a normal for loop will drop all space characters
# Parameters:
#   Skip (optional, 0 by default): The number of characters to skip
#   String (required): The string to split into separate characters
# Return: A newline separated sequence of characters from the input string
chars() {
  case $# in
    1) STR="$1" ;;
    2)
      STR="$2"
      SKIP="$1"

      # Make sure SKIP is not larger than the length of the string
      LEN="${#STR}"
      if [ $LEN -lt $SKIP ]; then
        SKIP="$LEN"
      fi

      # Remove a single character from the start of the string one character at a time
      while [ "$SKIP" -gt 0 ]; do
        STR="${STR#?}"
        SKIP=$((SKIP - 1))
      done
    ;;
    *) STR="$1"; warning 'Wrong number of arguments in the chars function' ;;
  esac

  while [ -n "$STR" ]; do
    # Remove the first character and store the remaining string in a temporary variable
    REST="${STR#?}"

    # Remove REST (everything but the first character) from the end of the string, resulting in the first character only
    CHAR="${STR%"$REST"}"
    echo "$CHAR"

    STR="$REST"
  done
}

# Prefixes every element in a sequence with the specified prefix
# Remark: Iterating over the resulting sequence using a normal for loop will split by any spaces in the prefix
# Parameters:
#   Prefix (required): The prefix to prepend to the start of every element
#   Elements.. (required): The elements to prepend the prefix to
# Return: A newline separated list of prefixed elements
prefix_all() {
  case $# in
    0 | 1) LIST=''; warning 'Wrong number of arguments in the prefix_all function' ;;
    *) PREFIX="$1"; shift; LIST="$*" ;;
  esac

  for ITEM in $LIST; do
    ITEM="$PREFIX$ITEM"
    # Use printf to handle cases where the prefix is a dash ('-') and the item is either 'n', 'e' or 'E'
    printf '%s\n' "$ITEM"
  done
}

# Separates option and value from the input in the format OPTION=VALUE
# Remark: This function uses and modifies the global OPTION and VALUE variables
# Parameters:
#   Option (optional, global OPTION variable by default): The option and its value delimited by an equals character
get_option_value() {
  case $# in
    0) ;;
    1) OPTION="$1" ;;
    *) OPTION="$1"; warning 'Wrong number of arguments in the get_option_value function' ;;
  esac

  case "$OPTION" in
    *=*) ;;
    *) error "'$OPTION' is not in the correct format" ;;
  esac

  VALUE="${OPTION#*=}"
  OPTION="${OPTION%%=*}"
}

# Parses a string into a base 10 integer number
# Flags:
#   {--negative|--non-positive|--non-negative|--positive}: The condition the parsed number must meet
# Parameters:
#   Number (required): The string to be parsed
# Return: The parsed number
parse_integer() {
  error_format() {
    error "'$NUMBER' is not in the correct number format"
  }

  error_condition() {
    error "'$NUMBER' must be ${FLAG#??}"
  }

  case $# in
    1) FLAG=''; NUMBER="$1" ;;
    2) FLAG="$1"; NUMBER="$2" ;;
    *) FLAG=''; NUMBER="$1"; warning 'Wrong number of arguments in the parse_integer function' ;;
  esac

  if [ -z "$NUMBER" ]; then
    error_format
  fi

  case "$NUMBER" in
    -*) NEGATIVE=1; NUMBER="${NUMBER#?}" ;;
    +*) NEGATIVE=0; NUMBER="${NUMBER#?}" ;;
    *) NEGATIVE=0 ;;
  esac

  case "$NUMBER" in
    *[!0123456789]*) error_format ;;
    0*)
      # Remove leading zeros to prevent the number being interpreted in base 8
      LEADING_ZEROS="${NUMBER%%[!0]*}"
      if [ -n "$LEADING_ZEROS" ]; then
        NUMBER="${NUMBER#"$LEADING_ZEROS"}"
        if [ -z "$NUMBER" ]; then NUMBER=0; fi
      fi
    ;;
  esac

  if [ $NEGATIVE -eq 1 ]; then
    NUMBER=$(( 0 - NUMBER ))
  else
    NUMBER=$(( NUMBER ))
  fi

  case "$FLAG" in
    --negative) if [ $NUMBER -ge 0 ]; then error_condition; fi ;;
    --non-positive) if [ $NUMBER -gt 0 ]; then error_condition; fi ;;
    --non-negative) if [ $NUMBER -lt 0 ]; then error_condition; fi ;;
    --positive) if [ $NUMBER -le 0 ]; then error_condition; fi ;;
    *) warning "'$FLAG' is not a recognized parse_integer option" ;;
  esac

  echo $NUMBER
}

# Determines the absolute path to a file or directory
# Parameters:
#   Path (required): The relative or absolute path to a file or directory
# Return: Absolute path to the specified file or directory
absolute_path() {
  ABSOLUTE_PATH=$(readlink -m "$1") || error "Failed to get the full path for $1"
  echo "$ABSOLUTE_PATH"
}

# Determines the absolute path to the parent directory
# Parameters:
#   Path (required): The relative or absolute path to a file or directory
# Return: Absolute path to the parent directory, or root if the input path is already root ('/')
absolute_dirname() {
  ABSOLUTE_PATH=$(absolute_path "$1")
  PARENT=$(dirname "$ABSOLUTE_PATH") || error "Failed to get the parent directory for $ABSOLUTE_PATH ($1)"
  echo "$PARENT"
}

# Determines the base name of a file or directory
# Parameters:
#   Path (required): The relative or absolute path to a file or directory
# Return: The base name of the specified file or directory
absolute_basename() {
  ABSOLUTE_PATH=$(absolute_path "$1")
  BASENAME=$(basename "$ABSOLUTE_PATH") || error "Failed to get the base name for $ABSOLUTE_PATH ($1)"
  echo "$BASENAME"
}

# Ensures that the specified path is not an existing file, and appends a slash if missing
# Remark: This function uses and modifies the global DIRECTORY variable
# Parameters:
#   Path (optional, global DIRECTORY variable by default): The path to be tested
assert_is_directory() {
  if [ $# -gt 0 ]; then
    DIRECTORY="$1"
  fi

  case "$DIRECTORY" in
    */) ;;
    *)
      if [ -f "$DIRECTORY" ]; then
        error "'$DIRECTORY' is a file"
      fi

      DIRECTORY="$DIRECTORY/"
    ;;
  esac
}

# Checks if the specified path ends on a slash, or is an existing directory and appends the specified file; Otherwise, leaves the path as is
# Parameters:
#   Path (required): Path to a directory or file
#   File (required): The file name to append to the input path if it's a directory
# Return: If the input path is a directory, the combined path of the directory with the imput file; Otherwise, the original path
append_file_if_dir() {
  DIR_OR_FILE="$1"
  FILE="$2"

  case "$DIR_OR_FILE" in
    */) echo "$DIR_OR_FILE$FILE" ;;
    *)
      if [ -d "$DIR_OR_FILE" ]; then
        echo "$DIR_OR_FILE/$FILE"
      else
        echo "$DIR_OR_FILE"
      fi
    ;;
  esac
}

# Checks if the specified docker volume exists, and prints a warning if it doesn't
# Flags:
#   --error: Exit with an error if the volume doesn't exist.
#            Takes priority over the --create flag
#   --create: Create a new volume if it doesn't exist
# Parameters:
#   VolumeName (optional, global VOLUME_NAME variable by default): The docker volume to be checked
volume_doesnot_exists() {
  ERROR=0
  CREATE=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          --error) ERROR=1 ;;
          --create) CREATE=1 ;;
          *) warning "'$OPTION' is not a recognized volume_doesnot_exists option"
        esac
      ;;
      *) break ;;
    esac
  done

  if [ $# -gt 0 ]; then
    VOLUME_NAME="$1"
  fi

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    if [ $ERROR -eq 1 ]; then
      error "Volume $VOLUME_NAME does not exist"
    elif [ $CREATE -eq 1 ]; then
      warning "Volume $VOLUME_NAME does not exist, creating..."
      docker volume create "$VOLUME_NAME" 1> /dev/null || error "Failed to create volume $VOLUME_NAME"
    else
      warning "Volume $VOLUME_NAME does not exist"
    fi
  fi
}

# Gets a space separated list of docker volumes
# Remark: This function uses and modifies the global VOLUME_NAMES variable
# Flags:
#   -i, --in-use: Only get volumes in use by at least one container
# Options:
#   -e, --exclude ExcludeList: Exclude the specified volumes from the final list.
#                              ExcludeList must be a comma separated list of volume names
get_volumes() {
  INUSE=0
  EXCLUDES=''

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -i | --in-use) INUSE=1 ;;
          -e | --exclude)
            if [ $# -ne 0 ]; then
              EXCLUDES=$(echo "$1" | tr ',' ' ') || error 'Failed to replace commas with spaces'
              shift
            else
              warning 'Wrong number of arguments in the get_volumes function'
            fi
          ;;
          *) warning "'$OPTION' is not a recognized get_volumes option"
        esac
      ;;
      *) break ;;
    esac
  done

  VOLUME_NAMES=$(docker volume ls -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of volumes'

  if [ -n "$EXCLUDES" ]; then
    VOLUMES=''

    for VOLUME_NAME in $VOLUME_NAMES; do
      SHOULD_EXCLUDE=0

      for EXCLUDE in $EXCLUDES; do
        if [ "$VOLUME_NAME" = "$EXCLUDE" ]; then
          SHOULD_EXCLUDE=1
          break
        fi
      done

      if [ $SHOULD_EXCLUDE -eq 0 ]; then
        if [ -z "$VOLUMES" ]; then
          VOLUMES="$VOLUME_NAME"
        else
          VOLUMES="$VOLUMES $VOLUME_NAME"
        fi
      fi
    done

    VOLUME_NAMES="$VOLUMES"
  fi

  if [ $INUSE -eq 1 ]; then
    VOLUMES=''

    for VOLUME_NAME in $VOLUME_NAMES; do
      CONTAINERS=$(docker ps -q -a --filter volume="$VOLUME_NAME") || error "Failed to get the list of containers using volume $VOLUME_NAME"

      if [ -n "$CONTAINERS" ]; then
        if [ -z "$VOLUMES" ]; then
          VOLUMES="$VOLUME_NAME"
        else
          VOLUMES="$VOLUMES $VOLUME_NAME"
        fi
      fi
    done

    VOLUME_NAMES="$VOLUMES"
  fi
}

# Transform a list of container names to 12 character container IDs
# Parameters:
#   Containers..: Container names
get_container_ids() {
  CONTAINER_IDS=''

  for CONTAINER_NAME in "$@"; do
    CONTAINER_ID=$(docker inspect --type=container --format='{{ .Id }}' "$CONTAINER_NAME") || error "Failed to find the container ID for '$CONTAINER_NAME'"
    CONTAINER_ID="${CONTAINER_ID%${CONTAINER_ID#????????????}}"

    if [ -z "$CONTAINER_IDS" ]; then
      CONTAINER_IDS="$CONTAINER_ID"
    else
      CONTAINER_IDS="$CONTAINER_IDS $CONTAINER_ID"
    fi
  done

  echo "$CONTAINER_IDS"
}

# Gets a space separated list of running container ids
# Remark: This function uses and modifies the global CONTAINERS variable
# Options:
#   -e, --exclude ExcludeList: Exclude the specified containers from the final list.
#                              ExcludeList must be a comma separated list of container names
# Parameters:
#   VolumeNames..: Only get containers that have one of the specified volumes as a mount point
get_running_containers() {
  EXCLUDES=''

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -e | --exclude)
            if [ $# -ne 0 ]; then
              EXCLUDES=$(echo "$1" | tr ',' ' ') || error 'Failed to replace commas with spaces'
              shift
            else
              warning 'Wrong number of arguments in the get_running_containers function'
            fi
          ;;
          *) warning "'$OPTION' is not a recognized get_running_containers option"
        esac
      ;;
      *) break ;;
    esac
  done

  if [ $# -eq 0 ]; then
    CONTAINERS=$(docker ps -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of running containers'
  elif [ $# -eq 1 ]; then
    VOLUME_NAME="$1"
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME" | tr '\n' ' ' | awk '{$1=$1;print}') || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
  else
    CONTAINERS=''
    for VOLUME_NAME in "$@"; do
      TMP=$(docker ps -q --filter volume="$VOLUME_NAME") || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
      CONTAINERS="$CONTAINERS $TMP"
    done
    CONTAINERS=$(echo "$CONTAINERS" | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to remove line separators, and leading and trailing spaces from the list of containers'

    CONTAINERS=$(echo "$CONTAINERS" | tr ' ' '\n' | sort -u | tr '\n' ' ') || error 'Failed to remove duplicates from the list of containers'
  fi

  if [ -n "$EXCLUDES" ]; then
    EXCLUDES=$(get_container_ids $EXCLUDES) || error 'Failed to find container IDs'

    CONS=''

    for CONTAINER in $CONTAINERS; do
      SHOULD_EXCLUDE=0

      for EXCLUDE in $EXCLUDES; do
        if [ "$CONTAINER" = "$EXCLUDE" ]; then
          SHOULD_EXCLUDE=1
          break
        fi
      done

      if [ $SHOULD_EXCLUDE -eq 0 ]; then
        if [ -z "$CONS" ]; then
          CONS="$CONTAINER"
        else
          CONS="$CONS $CONTAINER"
        fi
      fi
    done

    CONTAINERS="$CONS"
  fi
}

# Stops containers defined in the global CONTAINERS variable
# Remark: This function uses the global CONTAINERS variable
stop_containers() {
  if [ -n "$CONTAINERS" ]; then
    information 'Stopping containers' "$CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null || error 'Failed to stop containers'
  fi
}

# Restarts containers defined in the global CONTAINERS variable
# Remark: This function uses the global CONTAINERS variable
restart_containers() {
  if [ -n "$CONTAINERS" ]; then
    information 'Restarting containers' "$CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null || error 'Failed to restart containers'
  fi
}

# Gets a sorted list of files/directories in the current directory for the specified export format
# Parameters:
#   Type (required): One of file or directory
#   DatePosition (required): One of prefix, postfix or replace, however, replace is only valid if the Type parameter is directory
#   Filter (required): The name of the file/directory to filter for, which can only be empty if the DatePosition parameter is replace
#   Days (optional): Filter for files/directories at least this number of days old
get_previous_exports() {
  if [ $# -ge 3 ] && [ $# -le 4 ]; then
    case "$1" in
      file)
        TYPE='f'

        case "$2" in
          prefix) PREFIX=''; POSTFIX="_$3$EXTENSION" ;;
          postfix) PREFIX="$3_"; POSTFIX="$EXTENSION" ;;
          replace) error "'$2' is not a valid value for the DatePosition parameter in the get_previous_exports function in this context" ;;
          *) error "'$2' is not a valid value for the DatePosition parameter in the get_previous_exports function" ;;
        esac

        if [ -z "$3" ]; then
          error "'' is not a valid value for the Filter parameter in the get_previous_exports function in this context"
        fi
      ;;
      directory)
        TYPE='d'

        case "$2" in
          prefix) PREFIX=''; POSTFIX="_$3" ;;
          postfix) PREFIX="$3_"; POSTFIX='' ;;
          replace) PREFIX=''; POSTFIX='' ;;
          *) error "'$2' is not a valid value for the DatePosition parameter in the get_previous_exports function" ;;
        esac

        if [ "$2" != 'replace' ] && [ -z "$3" ]; then
          error "'' is not a valid value for the Filter parameter in the get_previous_exports function in this context"
        fi
      ;;
      *) error "'$1' is not a valid value for the Type parameter in the get_previous_exports function" ;;
    esac

    if [ $# -eq 4 ]; then
      FIND_ARGS="-mtime +$4"
    else
      FIND_ARGS=''
    fi
  else
    error 'Wrong number of arguments in the get_previous_exports function'
  fi

  RESULT=$(find . -mindepth 1 -maxdepth 1 -type "$TYPE" -name "${PREFIX}*-*-*_*-*-*${POSTFIX}" $FIND_ARGS -exec stat -c '%Y %n' {} +) \
    || error 'Failed to get the list of previous exports'

  # grep exits with code 1 if the input (output for find) is empty
  if [ -n "$RESULT" ]; then
    RESULT=$(\
      echo "$RESULT" \
      | grep -E "^[0-9]+(\.[0-9]+)? \./${PREFIX}[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}-[0-9]{2}-[0-9]{2}${POSTFIX}\$" \
      | sort -nr \
      | awk '{print substr($2,3)}' \
    ) || error 'Failed to get the list of previous exports'
  fi

  echo "$RESULT" # Double quotes needed to preserve newlines
}

# Exports the specified docker volume into an archive file
# Remark: Supports clustered flags, e.g. -abc instead of -a -b -c
# Flags:
#   -h, --help: Print the usage page
#   -p, --parents: Create parent directories for the archive file as needed
#   -f, --force: Overwrite the archive file if a file already exists
#   -s, --stop: Stop running containers that have the specified volume as a mount point before exporting, and restart them after
# Parameters:
#   VolumeName (required): The docker volume to export
#   Output (optional, ./ by default): The path to the output archive file. If the path points to a directory, a file inside the said directory with the name of the volume and archive extension will be assumed
command_export() {
  PARENTS=0
  OVERWRITE=0
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          -h | --help) print_usage --exit export ;;
          -p | --parents) PARENTS=1 ;;
          -f | --force) OVERWRITE=1 ;;
          -s | --stop) STOP=1 ;;
          *) error usage export "'$OPTION' is not a recognized export option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="./" ;;
    2) VOLUME_NAME="$1"; FILE_NAME="$2" ;;
    *) error usage export 'Wrong number of arguments' ;;
  esac

  FILE_NAME=$(append_file_if_dir "$FILE_NAME" "$VOLUME_NAME$EXTENSION")
  if [ -f "$FILE_NAME" ]; then
    if [ $OVERWRITE -eq 1 ]; then
      if [ ! -w "$FILE_NAME" ]; then
        error "Unable to write to '$FILE_NAME'"
      fi
    else
      error "File '$FILE_NAME' already exists"
    fi
  fi

  DIRECTORY=$(absolute_dirname "$FILE_NAME") || error "Faile to get the full path to the parent of $FILE_NAME"
  FILE_NAME=$(absolute_basename "$FILE_NAME") || error "Failed to get the base file name of $FILE_NAME"

  if [ $PARENTS -eq 1 ]; then
    if ! mkdir -p "$DIRECTORY"; then
      error "Failed to make parent directories for '$DIRECTORY/$FILE_NAME'"
    fi
  fi

  if [ ! -w "$DIRECTORY" ]; then
    error "Unable to write to '$DIRECTORY'"
  fi
  assert_is_directory

  volume_doesnot_exists --error

  if [ $STOP -eq 1 ]; then
    get_running_containers "$VOLUME_NAME"
  else
    CONTAINERS=''
  fi

  stop_containers

  TAR_OPTIONS='-zc'
  if [ $VERBOSE -eq 1 ]; then
    TAR_OPTIONS="${TAR_OPTIONS}v"
  fi
  TAR_OPTIONS="${TAR_OPTIONS}f" # Make sure the f option is last, since that's what GNU tar expects

  information 'Exporting volume' "$VOLUME_NAME"
  if [ $HOST -eq 1 ]; then
    MOUNTPOINT=$(docker inspect --type=volume --format '{{ .Mountpoint }}' "$VOLUME_NAME") || {
      restart_containers
      error 'Failed to get the mountpoint'
    }

    if ! tar $TAR_OPTIONS "$DIRECTORY/$FILE_NAME" -C "$MOUNTPOINT" .; then
      restart_containers
      error 'Failed to tar the volume'
    fi
  else
    if ! docker run --rm \
      -v "$VOLUME_NAME":/vackup-volume:ro \
      -v "$DIRECTORY":/vackup \
      busybox \
      tar $TAR_OPTIONS /vackup/"$FILE_NAME" -C /vackup-volume .; then
      restart_containers
      error 'Failed to start busybox backup container'
    fi
  fi

  restart_containers

  information --green 'Success' "Volume $VOLUME_NAME tar'ed into file '$FILE_NAME'"
}

# Imports the specified docker volume from an archive file
# Remark: Supports clustered flags, e.g. -abc instead of -a -b -c
# Flags:
#   -h, --help: Print the usage page
#   -s, --stop: Stop running containers that have the specified volume as a mount point before importing, and restart them after
# Parameters:
#   Input (optional, ./ by default): The path to the intput archive file. If the path points to a directory, a file inside the said directory with the name of the volume and archive extension will be assumed
#   VolumeName (required): The docker volume to import
command_import() {
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          -h | --help) print_usage --exit import ;;
          -s | --stop) STOP=1 ;;
          *) error usage import "'$OPTION' is not a recognized import option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="./" ;;
    2) FILE_NAME="$1"; VOLUME_NAME="$2" ;;
    *) error usage import 'Wrong number of arguments' ;;
  esac

  FILE_NAME=$(append_file_if_dir "$FILE_NAME" "$VOLUME_NAME$EXTENSION")
  if [ ! -r "$FILE_NAME" ]; then
    error "Could not find or open '$FILE_NAME'"
  fi

  DIRECTORY=$(absolute_dirname "$FILE_NAME") || error "Faile to get the full path to the parent of $FILE_NAME"
  FILE_NAME=$(absolute_basename "$FILE_NAME") || error "Failed to get the base file name of $FILE_NAME"
  assert_is_directory

  volume_doesnot_exists --create

  if [ $STOP -eq 1 ]; then
    get_running_containers "$VOLUME_NAME"
    stop_containers
  else
    CONTAINERS=''
  fi

  TAR_OPTIONS='--same-owner --same-permissions -xz'
  if [ $VERBOSE -eq 1 ]; then
    TAR_OPTIONS="${TAR_OPTIONS}v"
  fi
  TAR_OPTIONS="${TAR_OPTIONS}f" # Make sure the f option is last, since that's what GNU tar expects

  information 'Importing volume' "$VOLUME_NAME"
  if [ $HOST -eq 1 ]; then
    MOUNTPOINT=$(docker inspect --type=volume --format '{{ .Mountpoint }}' "$VOLUME_NAME") || {
      restart_containers
      error 'Failed to get the mountpoint'
    }

    if ! tar $TAR_OPTIONS "$DIRECTORY/$FILE_NAME" -C "$MOUNTPOINT"; then
      restart_containers
      error 'Failed to extract the tar archive into the volume'
    fi
  else
    if ! docker run --rm \
      -v "$VOLUME_NAME":/vackup-volume \
      -v "$DIRECTORY/$FILE_NAME":"/vackup/$FILE_NAME":ro \
      busybox \
      tar $TAR_OPTIONS /vackup/"$FILE_NAME" -C /vackup-volume; then
      restart_containers
      error 'Failed to start busybox backup container'
    fi
  fi

  restart_containers

  information --green 'Success' "Archive '$FILE_NAME' unpacked into volume $VOLUME_NAME"
}

# Exports all docker volume into archive files
# Remarks:
#   Supports clustered flags, e.g. -abc instead of -a -b -c
#   All exported archives will be named as the name of the volume and archive extension
# Flags:
#   -h, --help: Print the usage page
#   -p, --parents: Create parent directories for the archive files as needed
#   -f, --force: Overwrite the archive files if a file already exists
#   -i, --in-use: Only export volumes that are in use by at least one container
#   -s, --stop: Stop the running containers that mount a volume before exporting, and restart them after.
#               Takes priority over the -S, --stop-all flag
#   -S, --stop-all: Stop all running containers before exporting, and restart them after
#   {-d, --date|-D, --date-dir}:
#     -d, --date: Add the current date in the yyyy-MM-dd_HH-mm-ss ISOish format to the start of the archive file names.
#                 If the flag is passed in a second time, append the date to the end of the archive file names instead
#     -D, --date-dir: Use the current date in the yyyy-MM-dd_HH-mm-ss ISOish format as the output directory where the archive files will be exported to.
#                     This directory will be created inside the directory defined with the Output parameter.
#                     If the flag is passed in a second time, append the date to the start of the output directory name, instead of creating a new directory inside the output directory.
#                     If the flag is passed in a third time, append the date to the end of the output directory name instead
#   -u, --utc: Use UTC instead of the local timezone.
#              This option is valid only in conjunction with either --date or --date-dir
# Options:
#   --exclude-containers=CONTAINERS: Exclude the specified containers from being stopped, where CONTAINERS is a comma separated list of container names.
#                                    This option is valid only in conjunction with either --stop or --stop_all
#   --exclude-volumes=VOLUMES: Exlcude the specified volumes from being exported, where VOLUMES is a comma separated list of volume names
#   {-k, --keep=N|-K, --keep-days=DAYS}:
#     -k, --keep=N: Keep the most recent N exported directories/archives, and remove older ones.
#                   This option is valid only in conjunction with either --date or --date-dir
#     -K, --keep-days=DAYS: Remove exported directories/archives older than DAYS days.
#                           This option is valid only in conjunction with either --date or --date-dir
# Parameters:
#   Output (required): The path to the output directory where the archive files will be exported to
command_all_export() {
  ARGS=''
  PARENTS=0
  INUSE=0
  STOP=0
  STOP_ALL=0
  EXCLUDE_CONTAINERS=''
  EXCLUDE_VOLUMES=''
  DATE=0
  DATE_DIR=0
  UTC=0
  KEEP=0
  KEEP_DAYS=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          --exclude-containers | --exclude-volumes | -k | --keep | -K | --keep-days) error usage export-all "'$OPTION' requires a value" ;;
          -h | --help) print_usage --exit export-all ;;
          -p | --parents) PARENTS=1; ARGS="$ARGS --parents" ;;
          -f | --force) ARGS="$ARGS --force" ;;
          -i | --in-use) INUSE=1 ;;
          -s | --stop) STOP=1 ;;
          -S | --stop-all) STOP_ALL=1 ;;
          --exclude-containers=*) get_option_value; EXCLUDE_CONTAINERS="$VALUE" ;;
          --exclude-volumes=*) get_option_value; EXCLUDE_VOLUMES="$VALUE" ;;
          -d | --date | -D | --date-dir)
            if [ "$OPTION" = '-d' -o "$OPTION" = '--date' ] && [ $DATE_DIR -eq 0 ] && [ $DATE -lt 2 ]; then
              DATE=$((DATE + 1))
            elif [ "$OPTION" = '-D' -o "$OPTION" = '--date-dir' ] && [ $DATE -eq 0 ] && [ $DATE_DIR -lt 3 ]; then
              DATE_DIR=$((DATE_DIR + 1))
            else
              warning usage export-all "'$OPTION' passed too many times"
            fi
          ;;
          -u | --utc) UTC=1 ;;
          -k=* | --keep=* | -K=* | --keep-days=*)
            get_option_value
            VALUE=$(parse_integer --non-negative "$VALUE") || error "'$OPTION' option value failed to pass validation"

            if [ $KEEP -eq 0 ] && [ $KEEP_DAYS -eq 0 ]; then
              if [ "$OPTION" = '-k' ] || [ "$OPTION" = '--keep' ]; then
                KEEP=$VALUE
              else
                KEEP_DAYS=$VALUE
              fi
            else
              warning usage export-all "'$OPTION' passed too many times"
            fi
          ;;
          *) error usage export-all "'$OPTION' is not a recognized export option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1" ;;
    *) error usage export-all 'Wrong number of arguments' ;;
  esac

  if [ $DATE -ne 0 ] || [ $DATE_DIR -ne 0 ]; then
    if [ $UTC -eq 1 ]; then
      DATE_ARGS='-u'
    else
      DATE_ARGS=''
    fi

    CURRENT_DATE=$(date $DATE_ARGS +'%Y-%m-%d_%H-%M-%S') || error 'Failed to get the current date'
  else
    CURRENT_DATE=''
  fi
  if [ $DATE_DIR -ge 2 ]; then
    DIR_NAME=$(absolute_basename "$DIRECTORY") || error "Failed to get the base directory name to $DIRECTORY"
    PARENT="$(absolute_dirname "$DIRECTORY")/" || error "Faile to get the parent path to $DIRECTORY"
    DIRECTORY="$PARENT"
  fi
  case $DATE_DIR in
    0) assert_is_directory ;;
    1) assert_is_directory; DIRECTORY="${DIRECTORY}${CURRENT_DATE}/" ;;
    2) DIRECTORY="${DIRECTORY}${CURRENT_DATE}_${DIR_NAME}"; assert_is_directory ;;
    3) DIRECTORY="${DIRECTORY}${DIR_NAME}_${CURRENT_DATE}"; assert_is_directory ;;
    *) error "Impossible state of 'DATE_DIR': '$DATE_DIR'" ;;
  esac

  GET_VOLUMES_ARGS=''
  if [ $INUSE -eq 1 ]; then
    GET_VOLUMES_ARGS="$GET_VOLUMES_ARGS --in-use"
  fi
  if [ -n "$EXCLUDE_VOLUMES" ]; then
    GET_VOLUMES_ARGS="$GET_VOLUMES_ARGS --exclude $EXCLUDE_VOLUMES"
  fi
  get_volumes $GET_VOLUMES_ARGS

  if [ $STOP -eq 1 ] || [ $STOP_ALL -eq 1 ]; then
    GET_RUNNING_CONTAINERS_ARGS=''
    if [ -n "$EXCLUDE_CONTAINERS" ]; then
      GET_RUNNING_CONTAINERS_ARGS="$GET_RUNNING_CONTAINERS_ARGS --exclude $EXCLUDE_CONTAINERS"
    fi
    if [ $STOP -eq 1 ]; then
      GET_RUNNING_CONTAINERS_ARGS="$GET_RUNNING_CONTAINERS_ARGS $VOLUME_NAMES"
    fi
    get_running_containers $GET_RUNNING_CONTAINERS_ARGS

    stop_containers
  else
    CONTAINERS=''
  fi

  if [ $DATE_DIR -ne 0 ]; then
    if [ $PARENTS -eq 1 ]; then
      if ! mkdir -p "$DIRECTORY"; then
        error "Failed to make parent directories for '$DIRECTORY'"
      fi
    else
      if ! mkdir "$DIRECTORY"; then
        error "Failed to make directory '$DIRECTORY'"
      fi
    fi

    information 'Output directory' "$DIRECTORY"
  fi

  for VOLUME_NAME in $VOLUME_NAMES; do
    case $DATE in
      0) FILE_NAME="$DIRECTORY" ;;
      1) FILE_NAME="${DIRECTORY}${CURRENT_DATE}_${VOLUME_NAME}${EXTENSION}" ;;
      2) FILE_NAME="${DIRECTORY}${VOLUME_NAME}_${CURRENT_DATE}${EXTENSION}" ;;
      *) error "Impossible state of 'DATE': '$DATE'" ;;
    esac

    if ! (command_export $ARGS "$VOLUME_NAME" "$FILE_NAME"); then
      restart_containers
      error "Failed during $VOLUME_NAME volume export"
    fi
  done

  restart_containers

  information --green 'Success' "Volumes [$VOLUME_NAMES] tar'ed into archive files"

  if [ $(( DATE + DATE_DIR )) -ne 0 ] && [ $(( KEEP + KEEP_DAYS )) -ne 0 ]; then
    remove_exports() {
      OLD_IFS="$IFS"
      IFS='
'  # Set the Internal Field Separator to newline
      for EXPORT in $EXPORTS; do
        if [ $VERBOSE -eq 1 ]; then
          information 'Cleanup' "Removing $DIRECTORY$EXPORT"
        fi

        rm -rf "$DIRECTORY$EXPORT" || error "Failed to remove $DIRECTORY$EXPORT"
      done
      IFS="$OLD_IFS" # Reset the Internal Field Separator
    }

    if [ $DATE -ne 0 ]; then
      case $DATE in
        1) DATE_POSITION='prefix' ;;
        2) DATE_POSITION='postfix' ;;
        *) error "Impossible state of 'DATE': '$DATE'" ;;
      esac

      cd "$DIRECTORY"
      for VOLUME_NAME in $VOLUME_NAMES; do
        if [ $KEEP -ne 0 ]; then
          EXPORTS=$(get_previous_exports file "$DATE_POSITION" "$VOLUME_NAME" | tail -n +$(( KEEP + 1 )) | tac) \
            || error "Failed to get previous archive files for the '$VOLUME_NAME' volume"
        else
          EXPORTS=$(get_previous_exports file "$DATE_POSITION" "$VOLUME_NAME" $KEEP_DAYS | tac) \
            || error "Failed to get previous archive files for the '$VOLUME_NAME' volume"
        fi

        if [ -n "$EXPORTS" ]; then
          information 'Cleanup' "Removing previous archive files for the '$VOLUME_NAME' volume"
          remove_exports
        fi
      done
    else
      case $DATE_DIR in
        1)
          DATE_POSITION='replace'

          DIR_NAME='yyyy-MM-dd_HH-mm-ss'
          PARENT="$(absolute_dirname "$DIRECTORY")/" || error "Faile to get the parent path to $DIRECTORY"
        ;;
        2) DATE_POSITION='prefix' ;;
        3) DATE_POSITION='postfix' ;;
        *) error "Impossible state of 'DATE_DIR': '$DATE_DIR'" ;;
      esac

      DIRECTORY="$PARENT"
      cd "$DIRECTORY"
      if [ $KEEP -ne 0 ]; then
        EXPORTS=$(get_previous_exports directory "$DATE_POSITION" "$DIR_NAME" | tail -n +$(( KEEP + 1 )) | tac) \
          || error "Failed to get previous archive directories named '$DIR_NAME'"
      else
        EXPORTS=$(get_previous_exports directory "$DATE_POSITION" "$DIR_NAME" $KEEP_DAYS | tac) \
          || error "Failed to get previous archive directories named '$DIR_NAME'"
      fi

      if [ -n "$EXPORTS" ]; then
        information 'Cleanup' "Removing previous archive directories named '$DIR_NAME'"
        remove_exports
      fi
    fi
  fi
}

# Imports all docker volume from archive files
# Remarks:
#   Supports clustered flags, e.g. -abc instead of -a -b -c
#   All imported archives will be assumed to be named as the name of the volume and archive extension
# Flags:
#   -h, --help: Print the usage page
#   -s, --stop: Stop the running containers that mount a volume before importing, and restart them after.
#               Takes priority over the -S, --stop-all flag
#   -S, --stop-all: Stop all running containers before importing, and restart them after
# Options:
#   --exclude-containers=CONTAINERS: Exclude the specified containers from being stopped, where CONTAINERS is a comma separated list of container names.
#                                    This option is valid only in conjunction with either --stop or --stop_all
#   --exclude-volumes=VOLUMES: Exlcude the specified volumes from being imported, where VOLUMES is a comma separated list of volume names
# Parameters:
#   Input (required): The path to the intput directory where all the archive files to be imported are
command_all_import() {
  ARGS=''
  STOP=0
  STOP_ALL=0
  EXCLUDE_CONTAINERS=''
  EXCLUDE_VOLUMES=''

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          --exclude-containers | --exclude-volumes) error usage import-all "'$OPTION' requires a value" ;;
          -h | --help) print_usage --exit import-all ;;
          -s | --stop) STOP=1 ;;
          -S | --stop-all) STOP_ALL=1 ;;
          --exclude-containers=*) get_option_value; EXCLUDE_CONTAINERS="$VALUE" ;;
          --exclude-volumes=*) get_option_value; EXCLUDE_VOLUMES="$VALUE" ;;
          *) error usage import-all "'$OPTION' is not a recognized import option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1"; assert_is_directory ;;
    *) error usage import-all 'Wrong number of arguments' ;;
  esac

  GET_VOLUMES_ARGS=''
  if [ -n "$EXCLUDE_VOLUMES" ]; then
    GET_VOLUMES_ARGS="$GET_VOLUMES_ARGS --exclude $EXCLUDE_VOLUMES"
  fi
  get_volumes $GET_VOLUMES_ARGS

  if [ $STOP -eq 1 ] || [ $STOP_ALL -eq 1 ]; then
    GET_RUNNING_CONTAINERS_ARGS=''
    if [ -n "$EXCLUDE_CONTAINERS" ]; then
      GET_RUNNING_CONTAINERS_ARGS="$GET_RUNNING_CONTAINERS_ARGS --exclude $EXCLUDE_CONTAINERS"
    fi
    if [ $STOP -eq 1 ]; then
      GET_RUNNING_CONTAINERS_ARGS="$GET_RUNNING_CONTAINERS_ARGS $VOLUME_NAMES"
    fi
    get_running_containers $GET_RUNNING_CONTAINERS_ARGS

    stop_containers
  else
    CONTAINERS=''
  fi

  SUCCESSFUL=''
  for VOLUME_NAME in $VOLUME_NAMES; do
    FILE_NAME="$DIRECTORY$VOLUME_NAME$EXTENSION"

    if [ ! -f "$FILE_NAME" ]; then
      warning "'$FILE_NAME' was not found, skipping import of '$VOLUME_NAME' volume"
      continue
    fi

    if ! (command_import $ARGS "$FILE_NAME" "$VOLUME_NAME"); then
      restart_containers
      error "Failed during $VOLUME_NAME volume import"
    fi

    if [ -z "$SUCCESSFUL" ]; then
      SUCCESSFUL="$VOLUME_NAME"
    else
      SUCCESSFUL="$SUCCESSFUL $VOLUME_NAME"
    fi
  done

  restart_containers

  information --green 'Success' "Archives unpacked into volumes [$SUCCESSFUL]"
}

# Command for importing/exporting all volumes
# Remark: Supports clustered flags, e.g. -abc instead of -a -b -c
# Flags:
#   -h, --help: Print the usage page
# Parameters:
#   Subcommand (required): One of help, export or import.
#                          All subsequent arguments will be forwarded to the specified subcommand
command_all() {
  while [ $# -gt 0 ]; do
    COMMAND="$1"
    shift

    case "$COMMAND" in
      -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$COMMAND")) "$@" ;;
      -h | --help | help) print_usage --exit all ;;
      export) command_all_export "$@"; exit 0 ;;
      import) command_all_import "$@"; exit 0 ;;
      all | *) error usage all "'$COMMAND' is not a recognized command" ;;
    esac
  done

  print_usage --exit all
}

# Determine the current effective user ID
if [ -z "$BASH" ]; then
  EUID=$(id -u) || {
    warning 'Failed to determine the current effective user ID. Assuming 0'
    EUID=0
  }
fi

# Make sure we are running as root (ID 0)
if [ $EUID -ne 0 ]; then
  error 'This script must be run as root'
fi

# Redirect any output on the 3rd file descriptor to STDOUT, which is used to print messages even when STDOUT has been silenced
exec 3>&1

VERBOSE=0
HOST=0

# Argument parsing
# Remark: Supports clustered flags, e.g. -abc instead of -a -b -c
# Flags:
#   -h, --help: Print the usage page
#   -q, --quiet: Silence the outputs to STDOUT, except if the usage page is explicitly requested
#   -v, --verbose: Verbose printing
#   -H, --host: Do the export/import by running the archive program on the host instead of a container
# Parameters:
#   Command (required): One of help, export, import or all.
#                       All subsequent arguments will be forwarded to the specified command
while [ $# -gt 0 ]; do
  COMMAND="$1"
  shift

  case "$COMMAND" in
    -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$COMMAND")) "$@" ;;
    -h | --help | help) print_usage --exit ;;
    -q | --quiet) exec 3>&1 1>/dev/null ;;
    -v | --verbose) VERBOSE=1 ;;
    -H | --host) HOST=1 ;;
    export) command_export "$@"; exit 0 ;;
    import) command_import "$@"; exit 0 ;;
    all) command_all "$@"; exit 0 ;;
    *) error usage main "'$COMMAND' is not a recognized command" ;;
  esac
done

print_usage --exit

exit 0
