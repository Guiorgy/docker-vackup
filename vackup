#!/usr/bin/env bash
# Docker Volume File Backup and Restore Tool
# Easily tar up a volume on a local (or remote) engine
# Inspired by CLIP from Lukasz Lach

if [ -z "$LINENO" ]; then
  LINENO='unknown'
fi

if command -v caller 1> /dev/null 2>&1; then
  CALLER=1
else
  CALLER=0
fi

if [ -z "$BASH" ]; then
  BASH=''
fi

if [ -z "$VACKUP_FAILURE_SCRIPT" ]; then
  VACKUP_FAILURE_SCRIPT=''
fi

if [ -n "$BASH" ]; then
  set -Eeuo pipefail
else
  set -eu
fi

handle_error() {
  case $# in
    1) LINE_NUMBER=$1; EXIT_CODE=$? ;;
    2) LINE_NUMBER=$1; EXIT_CODE=$2 ;;
    *) LINE_NUMBER=$LINENO; EXIT_CODE=1 ;;
  esac

  if [ -n "$VACKUP_FAILURE_SCRIPT" ]; then
    /usr/bin/env bash "$VACKUP_FAILURE_SCRIPT" "$LINE_NUMBER" $EXIT_CODE
  fi

  exit $EXIT_CODE
}

if [ -n "$BASH" ]; then
  trap 'handle_error $LINENO' ERR
else
  trap 'handle_error $LINENO $?' EXIT
fi

if [ -t 1 ]; then
  RESET_COLOR='\033[0m'

  BLACK_COLOR='\033[0;30m'
  RED_COLOR='\033[0;31m'
  GREEN_COLOR='\033[0;32m'
  YELLOW_COLOR='\033[0;33m'
  BLUE_COLOR='\033[0;34m'
  PURPLE_COLOR='\033[0;35m'
  CYAN_COLOR='\033[0;36m'
  WHITE_COLOR='\033[0;37m'

  BOLD_BLACK_COLOR='\033[1;30m'
  BOLD_RED_COLOR='\033[1;31m'
  BOLD_GREEN_COLOR='\033[1;32m'
  BOLD_YELLOW_COLOR='\033[1;33m'
  BOLD_BLUE_COLOR='\033[1;34m'
  BOLD_PURPLE_COLOR='\033[1;35m'
  BOLD_CYAN_COLOR='\033[1;36m'
  BOLD_WHITE_COLOR='\033[1;37m'
else
  RESET_COLOR=''

  BLACK_COLOR=''
  RED_COLOR=''
  GREEN_COLOR=''
  YELLOW_COLOR=''
  BLUE_COLOR=''
  PURPLE_COLOR=''
  CYAN_COLOR=''
  WHITE_COLOR=''

  BOLD_BLACK_COLOR=''
  BOLD_RED_COLOR=''
  BOLD_GREEN_COLOR=''
  BOLD_YELLOW_COLOR=''
  BOLD_BLUE_COLOR=''
  BOLD_PURPLE_COLOR=''
  BOLD_CYAN_COLOR=''
  BOLD_WHITE_COLOR=''
fi

if [ -t 2 ]; then
  RESET_COLOR_ERR='\033[0m'

  BLACK_COLOR_ERR='\033[0;30m'
  RED_COLOR_ERR='\033[0;31m'
  GREEN_COLOR_ERR='\033[0;32m'
  YELLOW_COLOR_ERR='\033[0;33m'
  BLUE_COLOR_ERR='\033[0;34m'
  PURPLE_COLOR_ERR='\033[0;35m'
  CYAN_COLOR_ERR='\033[0;36m'
  WHITE_COLOR_ERR='\033[0;37m'

  BOLD_BLACK_COLOR_ERR='\033[1;30m'
  BOLD_RED_COLOR_ERR='\033[1;31m'
  BOLD_GREEN_COLOR_ERR='\033[1;32m'
  BOLD_YELLOW_COLOR_ERR='\033[1;33m'
  BOLD_BLUE_COLOR_ERR='\033[1;34m'
  BOLD_PURPLE_COLOR_ERR='\033[1;35m'
  BOLD_CYAN_COLOR_ERR='\033[1;36m'
  BOLD_WHITE_COLOR_ERR='\033[1;37m'
else
  RESET_COLOR_ERR=''

  BLACK_COLOR_ERR=''
  RED_COLOR_ERR=''
  GREEN_COLOR_ERR=''
  YELLOW_COLOR_ERR=''
  BLUE_COLOR_ERR=''
  PURPLE_COLOR_ERR=''
  CYAN_COLOR_ERR=''
  WHITE_COLOR_ERR=''

  BOLD_BLACK_COLOR_ERR=''
  BOLD_RED_COLOR_ERR=''
  BOLD_GREEN_COLOR_ERR=''
  BOLD_YELLOW_COLOR_ERR=''
  BOLD_BLUE_COLOR_ERR=''
  BOLD_PURPLE_COLOR_ERR=''
  BOLD_CYAN_COLOR_ERR=''
  BOLD_WHITE_COLOR_ERR=''
fi

print_usage() {
  STDERR=0
  EXIT=0

  while [ $# -ne 0 ]; do
    case "$1" in
      --err) STDERR=1 ;;
      --exit) EXIT=1 ;;
    esac

    shift
  done

  TEXT=$(cat <<EOF

"Docker Volume Backup". Replicates image management commands for volumes.

export/import copies files between a host tarball and a volume. For making
  volume backups and restores.

Usage:

vackup export VOLUME FILE
  Creates a gzip'ed tarball in the current directory from a volume

vackup import FILE VOLUME
  Extracts a gzip'ed tarball into a volume

EOF
  ) || error "Failed to generate the usage text"

  if [ $STDERR -eq 1 ]; then
    echo 1>&2 "$TEXT"
  else
    echo 1>&3 "$TEXT"
  fi

  if [ $EXIT -eq 1 ]; then
    if [ $STDERR -eq 1 ]; then
      if [ $CALLER -eq 1 ]; then
        LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
        handle_error $LINE_NUMBER 1
      else
        exit 1
      fi
    else
      exit 0
    fi
  fi
}

warning() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      USAGE=1
      shift
    else
      USAGE=0
    fi

    case $# in
      0) MESSAGE='' ;;
      1) MESSAGE=$1 ;;
      *) warning 'Wrong number of arguments'; MESSAGE=$1 ;;
    esac
  else
    USAGE=0
    MESSAGE=''
  fi

  if [ -z "$MESSAGE" ]; then
    echo 1>&2 -e "${BOLD_YELLOW_COLOR_ERR}Warning${RESET_COLOR_ERR}"
  else
    echo 1>&2 -e "${BOLD_YELLOW_COLOR_ERR}Warning${RESET_COLOR_ERR}: $MESSAGE"
  fi

  if [ $USAGE -eq 1 ]; then
    print_usage --err
  fi
}

error() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      USAGE=1
      shift
    else
      USAGE=0
    fi

    case $# in
      0) MESSAGE=''; CODE=1 ;;
      1) MESSAGE=$1; CODE=1 ;;
      2) MESSAGE=$1; CODE=$2 ;;
      *) warning 'Wrong number of arguments'; MESSAGE=$1; CODE=$2 ;;
    esac
  else
    USAGE=0
    MESSAGE=''
    CODE=1
  fi

  if [ -z "$MESSAGE" ]; then
    echo 1>&2 -e "${BOLD_RED_COLOR_ERR}Error${RESET_COLOR_ERR}"
  else
    echo 1>&2 -e "${BOLD_RED_COLOR_ERR}Error${RESET_COLOR_ERR}: $MESSAGE"
  fi

  if [ $USAGE -eq 1 ]; then
    print_usage --err
  fi

  if [ $CALLER -eq 1 ]; then
    LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
    handle_error $LINE_NUMBER $CODE
  else
    exit $CODE
  fi
}

information() {
  COLOR="$BLUE_COLOR"

  if [ $# -ne 0 ]; then
    case "$1" in
      --*)
        case "$1" in
          --no-color) COLOR="$RESET_COLOR" ;;
          --black) COLOR="$BLACK_COLOR" ;;
          --red) COLOR="$RED_COLOR" ;;
          --green) COLOR="$GREEN_COLOR" ;;
          --yellow) COLOR="$YELLOW_COLOR" ;;
          --blue) COLOR="$BLUE_COLOR" ;;
          --purple) COLOR="$PURPLE_COLOR" ;;
          --cyan) COLOR="$CYAN_COLOR" ;;
          --white) COLOR="$WHITE_COLOR" ;;
          *) warning 'unrecognized color' ;;
        esac

        shift
      ;;
      *) ;;
    esac
  fi

  case $# in
    1) MESSAGE=$1 ;;
    2) MESSAGE="${COLOR}$1${RESET_COLOR}: $2" ;;
    *) warning 'Wrong number of arguments'; MESSAGE=$1 ;;
  esac

  echo -e "$MESSAGE"
}

fulldirname() {
  DIRECTORY=$(dirname "$1") || error "Failed to get the parent directory for $1"

  case "$DIRECTORY" in
    /*) ;;
    .*) DIRECTORY="$(pwd)/$DIRECTORY" ;;
    *) DIRECTORY="$(pwd)/$DIRECTORY" ;;
  esac
  DIRECTORY=$(readlink -m "$DIRECTORY") || error "Failed to get the full path for $DIRECTORY"

  echo "$DIRECTORY"
}

command_export() {
  PARENTS=0
  OVERWRITE=0
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        case "$1" in
          -h) print_usage --exit ;;
          --help) print_usage --exit ;;
          -p) PARENTS=1 ;;
          --parents) PARENTS=1 ;;
          -f) OVERWRITE=1 ;;
          --force) OVERWRITE=1 ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized export option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="$VOLUME_NAME.tar.gz" ;;
    2) VOLUME_NAME="$1"; FILE_NAME="$2" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$FILE_NAME" in
    */) FILE_NAME="$FILE_NAME$VOLUME_NAME.tar.gz" ;;
    *)
      if [ -d "$FILE_NAME" ]; then
        FILE_NAME="$FILE_NAME/$VOLUME_NAME.tar.gz"
      fi
    ;;
  esac

  if [ -f "$FILE_NAME" ]; then
    if [ $OVERWRITE -eq 1 ]; then
      if [ ! -w "$FILE_NAME" ]; then
        error "Unable to write to '$FILE_NAME'"
      fi
    else
      error "File '$FILE_NAME' already exists"
    fi
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME") || error "Faile to get the full path for $FILE_NAME"
  FILE_NAME=$(basename "$FILE_NAME") || error "Failed to get the file name for $FILE_NAME"

  if [ $PARENTS -eq 1 ]; then
    if ! mkdir -p "$DIRECTORY"; then
      error "Failed to make parent directories for '$DIRECTORY/$FILE_NAME'"
    fi
  fi

  if [ ! -w "$DIRECTORY" ]; then
    error "Unable to write to '$DIRECTORY'"
  fi

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    error "Volume $VOLUME_NAME does not exist"
  fi

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME" | tr '\n' ' ' | awk '{$1=$1;print}') || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    information 'Stopping containers' "$CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi
  restart_containers() {
    if [ -n "$CONTAINERS" ]; then
      information 'Restarting containers' "$CONTAINERS"
      docker restart $CONTAINERS 1> /dev/null
    fi
  }

  TAR_OPTIONS='-zc'
  if [ $VERBOSE -eq 1 ]; then
    TAR_OPTIONS="${TAR_OPTIONS}v"
  fi
  TAR_OPTIONS="${TAR_OPTIONS}f"

  information 'Exporting volume' "$VOLUME_NAME"
  if [ $HOST -eq 1 ]; then
    MOUNTPOINT=$(docker inspect --format '{{ .Mountpoint }}' "$VOLUME_NAME") || {
      restart_containers
      error 'Failed to get the mountpoint'
    }

    if ! tar $TAR_OPTIONS "$DIRECTORY/$FILE_NAME" -C "$MOUNTPOINT" .; then
      restart_containers
      error 'Failed to tar the volume'
    fi
  else
    if ! docker run --rm \
      -v "$VOLUME_NAME":/vackup-volume:ro \
      -v "$DIRECTORY":/vackup \
      busybox \
      tar $TAR_OPTIONS /vackup/"$FILE_NAME" -C /vackup-volume .; then
      restart_containers
      error 'Failed to start busybox backup container'
    fi
  fi

  restart_containers

  information --green 'Success' "Volume $VOLUME_NAME tar'ed into file '$FILE_NAME'"
}

command_import() {
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        case "$1" in
          -h) print_usage --exit ;;
          --help) print_usage --exit ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized import option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="$VOLUME_NAME.tar.gz" ;;
    2) FILE_NAME="$1"; VOLUME_NAME="$2" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$FILE_NAME" in
    */) FILE_NAME="$FILE_NAME$VOLUME_NAME.tar.gz" ;;
    *)
      if [ -d "$FILE_NAME" ]; then
        FILE_NAME="$FILE_NAME/$VOLUME_NAME.tar.gz"
      fi
    ;;
  esac

  if [ ! -r "$FILE_NAME" ]; then
    error "Could not find or open '$FILE_NAME'"
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME") || error "Faile to get the full path for $FILE_NAME"
  FILE_NAME=$(basename "$FILE_NAME") || error "Failed to get the file name for $FILE_NAME"

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    warning "Volume $VOLUME_NAME does not exist, creating..."
    docker volume create "$VOLUME_NAME" 1> /dev/null
  fi

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME" | tr '\n' ' ' | awk '{$1=$1;print}') || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    information 'Stopping containers' "$CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi
  restart_containers() {
    if [ -n "$CONTAINERS" ]; then
      information 'Restarting containers' "$CONTAINERS"
      docker restart $CONTAINERS 1> /dev/null
    fi
  }

  TAR_OPTIONS='-xz'
  if [ $VERBOSE -eq 1 ]; then
    TAR_OPTIONS="${TAR_OPTIONS}v"
  fi
  TAR_OPTIONS="${TAR_OPTIONS}f"

  information 'Importing volume' "$VOLUME_NAME"
  if [ $HOST -eq 1 ]; then
    MOUNTPOINT=$(docker inspect --format '{{ .Mountpoint }}' "$VOLUME_NAME") || {
      restart_containers
      error 'Failed to get the mountpoint'
    }

    if ! tar $TAR_OPTIONS "$DIRECTORY/$FILE_NAME" -C "$MOUNTPOINT"; then
      restart_containers
      error 'Failed to extract the tar archive into the volume'
    fi
  else
    if ! docker run --rm \
      -v "$VOLUME_NAME":/vackup-volume \
      -v "$DIRECTORY/$FILE_NAME":"/vackup/$FILE_NAME":ro \
      busybox \
      tar $TAR_OPTIONS /vackup/"$FILE_NAME" -C /vackup-volume; then
      restart_containers
      error 'Failed to start busybox backup container'
    fi
  fi

  restart_containers

  information --green 'Success' "Archive '$FILE_NAME' unpacked into volume $VOLUME_NAME"
}

command_all_export() {
  ARGS=''
  INUSE=0
  STOP=0

  while [ $# -ne 1 ]; do
    case "$1" in
      -*)
        case "$1" in
          -h) print_usage --exit ;;
          --help) print_usage --exit ;;
          -p) ARGS="$ARGS -p" ;;
          --parents) ARGS="$ARGS --parents" ;;
          -f) ARGS="$ARGS -f" ;;
          --force) ARGS="$ARGS --force" ;;
          -i) INUSE=1 ;;
          --in-use) INUSE=1 ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized export option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$DIRECTORY" in
    */) ;;
    *)
      if [ -f "$DIRECTORY" ]; then
        error "'$DIRECTORY' is a file"
      fi

      DIRECTORY="$DIRECTORY/"
    ;;
  esac

  VOLUME_NAMES=$(docker volume ls -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of volumes'

  if [ $INUSE -eq 1 ]; then
    VOLUMES=''

    for VOLUME_NAME in $VOLUME_NAMES; do
      CONTAINERS=$(docker ps -q -a -f volume="$VOLUME_NAME") || error 'Failed to get the list of volumes in use by containers'

      if [ -n "$CONTAINERS" ]; then
        if [ -z "$VOLUMES" ]; then
          VOLUMES="$VOLUME_NAME"
        else
          VOLUMES="$VOLUMES $VOLUME_NAME"
        fi
      fi
    done

    VOLUME_NAMES="$VOLUMES"
  fi

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of running containers'
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    information 'Stopping containers' "$CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi

  FAILED=''
  for VOLUME_NAME in $VOLUME_NAMES; do
    if ! (command_export $ARGS "$VOLUME_NAME" "$DIRECTORY"); then
      FAILED="$VOLUME_NAME"
      break
    fi
  done

  if [ -n "$CONTAINERS" ]; then
    information 'Restarting containers' "$CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null
  fi

  if [ -n "$FAILED" ]; then
    error "Failed during $FAILED volume export"
  fi

  information --green 'Success' "Volumes [$VOLUME_NAMES] tar'ed into archive files"
}

command_all_import() {
  ARGS=''
  STOP=0

  while [ $# -ne 1 ]; do
    case "$1" in
      -*)
        case "$1" in
          -h) print_usage --exit ;;
          --help) print_usage --exit ;;
          -s) STOP=1 ;;
          --stop) STOP=1 ;;
          *) error usage "'$1' is not a recognized import option" ;;
        esac

        shift
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1" ;;
    *) error usage 'Wrong number of arguments' ;;
  esac

  case "$DIRECTORY" in
    */) ;;
    *)
      if [ -f "$DIRECTORY" ]; then
        error "'$DIRECTORY' is a file"
      fi

      DIRECTORY="$DIRECTORY/"
    ;;
  esac

  VOLUME_NAMES=$(docker volume ls -q) || error 'Failed to get the list of volumes'

  if [ $STOP -eq 1 ]; then
    CONTAINERS=$(docker ps -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of running containers'
  else
    CONTAINERS=''
  fi

  if [ -n "$CONTAINERS" ]; then
    information 'Stopping containers' "$CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null
  fi

  SUCCESSFUL=''
  FAILED=''
  for VOLUME_NAME in $VOLUME_NAMES; do
    FILE_NAME="$DIRECTORY$VOLUME_NAME.tar.gz"

    if [ ! -f "$FILE_NAME" ]; then
      warning "'$FILE_NAME' was not found, skipping import of '$VOLUME_NAME' volume"
      continue
    fi

    if ! (command_import $ARGS "$FILE_NAME" "$VOLUME_NAME"); then
      FAILED="$VOLUME_NAME"
      break
    fi

    if [ -z "$SUCCESSFUL" ]; then
      SUCCESSFUL="$VOLUME_NAME"
    else
      SUCCESSFUL="$SUCCESSFUL $VOLUME_NAME"
    fi
  done

  if [ -n "$CONTAINERS" ]; then
    information 'Restarting containers' "$CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null
  fi

  if [ -n "$FAILED" ]; then
    error "Failed during $FAILED volume import"
  fi

  information --green 'Success' "Archives unpacked into volumes [$SUCCESSFUL]"
}

command_all() {
  if [ $# -eq 0 ]; then
    print_usage --exit
  fi

  COMMAND="$1"
  shift
  case "$COMMAND" in
    -h) print_usage --exit ;;
    --help) print_usage --exit ;;
    help) print_usage --exit ;;
    export) command_all_export "$@" ;;
    import) command_all_import "$@" ;;
    all) error usage "'$COMMAND' is not a recognized command" ;;
    *) error usage "'$COMMAND' is not a recognized command" ;;
  esac
}

exec 3>&1
VERBOSE=0
HOST=0

parse_command() {
  if [ $# -eq 0 ]; then
    print_usage --exit
  fi

  COMMAND="$1"
  shift
  case "$COMMAND" in
    -h) print_usage --exit ;;
    --help) print_usage --exit ;;
    help) print_usage --exit ;;
    -q) exec 3>&1 1>/dev/null; parse_command "$@" ;;
    --quiet) exec 3>&1 1>/dev/null; parse_command "$@" ;;
    -v) VERBOSE=1 ; parse_command "$@" ;;
    --verbose) VERBOSE=1 ; parse_command "$@" ;;
    -H) HOST=1 ; parse_command "$@" ;;
    --host) HOST=1 ; parse_command "$@" ;;
    export) command_export "$@" ;;
    import) command_import "$@" ;;
    all) command_all "$@" ;;
    *) error usage "'$COMMAND' is not a recognized command" ;;
  esac
}

parse_command "$@"

exit 0
