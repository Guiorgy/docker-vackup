#!/usr/bin/env bash

# Docker Volume File Backup and Restore Tool
# Easily tar up a volume on a local (or remote) engine
# Base on vackup by Bret Fisher
# Inspired by CLIP from Lukasz Lach
#
# This script targets bash for better error handling, which isn't required
# It checks the BASH variable, and falls back to POSIX compliance if not set
# It (hopefully) works with any POSIX shell

# The file name of the script in case it was renamed
VACKUP=$(basename "$0")

# Some shells don't support this (looking at you dash)
if [ -z "$LINENO" ]; then
  LINENO='unknown'
fi

# Silently check if the caller command is defined
if command -v caller 1> /dev/null 2>&1; then
  CALLER=1
else
  CALLER=0
fi

# Check if we are in bash
if [ -z "$BASH" ]; then
  BASH=''
fi

# Define VACKUP_FAILURE_SHELL and VACKUP_FAILURE_SCRIPT if not defined
if [ -z "$VACKUP_FAILURE_SHELL" ]; then
  VACKUP_FAILURE_SHELL=''
fi
if [ -z "$VACKUP_FAILURE_SCRIPT" ]; then
  VACKUP_FAILURE_SCRIPT=''
fi

# Modify shell behavior
if [ -n "$BASH" ]; then
  # -E: The trap on ERR is inherited by shell functions, command substitutions, and commands executed in a subshell environment
  # -e: Exit immediately if a pipeline returns a non-zero status
  # -u: The shell shall write a message to standard error when it tries to expand a variable that is not set and immediately exit
  # -o pipefail: The return value of a pipeline is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands in the pipeline exit successfully
  set -Eeuo pipefail
else
  set -eu
fi

# Executes the VACKUP_FAILURE_SCRIPT script with line number and error code as arguments using the VACKUP_FAILURE_SHELL shell and exit
# Remark: Line number may be 'unknown' on some shells, e.g. dash
# Executed when an error is trapped, or the error function is called
# Parameters:
#   LineNumber (required): The line number of the failed command
#   ExitCode (optional): The error code of the failed command
handle_error() {
  case $# in
    1) LINE_NUMBER=$1; EXIT_CODE=$? ;;
    2) LINE_NUMBER=$1; EXIT_CODE=$2 ;;
    *) LINE_NUMBER=$LINENO; EXIT_CODE=1 ;;
  esac

  if [ -n "$VACKUP_FAILURE_SCRIPT" ]; then
    if [ -z "$VACKUP_FAILURE_SHELL" ]; then
      if [ -n "$BASH" ]; then
        VACKUP_FAILURE_SHELL="$BASH"
      else
        VACKUP_FAILURE_SHELL=$(command -v sh 2> /dev/null) || 'sh'
      fi
    fi

    "$VACKUP_FAILURE_SHELL" "$VACKUP_FAILURE_SCRIPT" "$LINE_NUMBER" $EXIT_CODE
  fi

  exit $EXIT_CODE
}

# Set up a trap
if [ -n "$BASH" ]; then
  trap 'handle_error $LINENO' ERR
else
  trap 'handle_error $LINENO $?' EXIT
fi

# Initialize colors for STDOUT if it's connected to a tty
if [ -t 1 ]; then
  RESET_COLOR='\033[0m'

  BLACK_COLOR='\033[0;30m'
  RED_COLOR='\033[0;31m'
  GREEN_COLOR='\033[0;32m'
  YELLOW_COLOR='\033[0;33m'
  BLUE_COLOR='\033[0;34m'
  PURPLE_COLOR='\033[0;35m'
  CYAN_COLOR='\033[0;36m'
  WHITE_COLOR='\033[0;37m'

  BOLD_BLACK_COLOR='\033[1;30m'
  BOLD_RED_COLOR='\033[1;31m'
  BOLD_GREEN_COLOR='\033[1;32m'
  BOLD_YELLOW_COLOR='\033[1;33m'
  BOLD_BLUE_COLOR='\033[1;34m'
  BOLD_PURPLE_COLOR='\033[1;35m'
  BOLD_CYAN_COLOR='\033[1;36m'
  BOLD_WHITE_COLOR='\033[1;37m'
else
  RESET_COLOR=''

  BLACK_COLOR=''
  RED_COLOR=''
  GREEN_COLOR=''
  YELLOW_COLOR=''
  BLUE_COLOR=''
  PURPLE_COLOR=''
  CYAN_COLOR=''
  WHITE_COLOR=''

  BOLD_BLACK_COLOR=''
  BOLD_RED_COLOR=''
  BOLD_GREEN_COLOR=''
  BOLD_YELLOW_COLOR=''
  BOLD_BLUE_COLOR=''
  BOLD_PURPLE_COLOR=''
  BOLD_CYAN_COLOR=''
  BOLD_WHITE_COLOR=''
fi

# Initialize colors for STDERR if it's connected to a tty
if [ -t 2 ]; then
  RESET_COLOR_ERR='\033[0m'

  BLACK_COLOR_ERR='\033[0;30m'
  RED_COLOR_ERR='\033[0;31m'
  GREEN_COLOR_ERR='\033[0;32m'
  YELLOW_COLOR_ERR='\033[0;33m'
  BLUE_COLOR_ERR='\033[0;34m'
  PURPLE_COLOR_ERR='\033[0;35m'
  CYAN_COLOR_ERR='\033[0;36m'
  WHITE_COLOR_ERR='\033[0;37m'

  BOLD_BLACK_COLOR_ERR='\033[1;30m'
  BOLD_RED_COLOR_ERR='\033[1;31m'
  BOLD_GREEN_COLOR_ERR='\033[1;32m'
  BOLD_YELLOW_COLOR_ERR='\033[1;33m'
  BOLD_BLUE_COLOR_ERR='\033[1;34m'
  BOLD_PURPLE_COLOR_ERR='\033[1;35m'
  BOLD_CYAN_COLOR_ERR='\033[1;36m'
  BOLD_WHITE_COLOR_ERR='\033[1;37m'
else
  RESET_COLOR_ERR=''

  BLACK_COLOR_ERR=''
  RED_COLOR_ERR=''
  GREEN_COLOR_ERR=''
  YELLOW_COLOR_ERR=''
  BLUE_COLOR_ERR=''
  PURPLE_COLOR_ERR=''
  CYAN_COLOR_ERR=''
  WHITE_COLOR_ERR=''

  BOLD_BLACK_COLOR_ERR=''
  BOLD_RED_COLOR_ERR=''
  BOLD_GREEN_COLOR_ERR=''
  BOLD_YELLOW_COLOR_ERR=''
  BOLD_BLUE_COLOR_ERR=''
  BOLD_PURPLE_COLOR_ERR=''
  BOLD_CYAN_COLOR_ERR=''
  BOLD_WHITE_COLOR_ERR=''
fi

# Prints usage and exits if necessary
# Flags:
#   --err (optional): Print to STDERR instead of STDOUT
#   --exit (optional): Exit after printing usage. If --err is also set, exit with the error code 1
# Parameters:
#   For (optional, main by default): One of main, export, import, all, export-all or import-all
print_usage() {
  STDERR=0
  EXIT=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          --err) STDERR=1 ;;
          --exit) EXIT=1 ;;
          *) warning "'$OPTION' is not a recognized print_usage option"
        esac
      ;;
      *) break ;;
    esac
  done

  if [ $# -eq 0 ]; then
    FOR='main'
  else
    FOR="$1"

    if [ $# -gt 1 ]; then
      warning 'Wrong number of arguments in the print_usage function'
    fi
  fi

  case "$FOR" in
    main)
      TEXT=$(cat <<EOF

Usage: $VACKUP [OPTIONS] COMMAND

"Docker Volume Backup". Replicates image management commands for volumes.

Commands:
  help        Print this help page
  export      Export a docker volume into an archive file
  import      Import a docker volume from an archive file
  all         Export/import multiple docker volumes to/from archive files

Options:
  -h, --help        Print this help page
  -q, --quiet       Silence the outputs to STDOUT, except if the help page is
                    explicitly requested
  -v, --verbose     Verbose printing
  -H, --host        Do the export/import by running the archive program on the
                    host instead of a container

Run '$VACKUP COMMAND --help' for more information on a command.

EOF
      ) || error "Failed to generate the usage text"
    ;;
    export)
      TEXT=$(cat <<EOF

Usage: $VACKUP export [OPTIONS] VOLUME_NAME [OUTPUT]

Export a docker volume into an archive file

Parameters:
  VOLUME_NAME     The docker volume to export
  OUTPUT          The path to the output archive file. If the path points to a
                  directory, a file inside the said directory with the name of
                  the volume and archive extension will be assumed

Options:
  -h, --help        Print this help page
  -p, --parents     Create parent directories for the archive file as needed
  -f, --force       Overwrite the archive file if a file already exists
  -s, --stop        Stop running containers that have the specified volume as a
                    mount point before exporting, and restart them after

EOF
      ) || error "Failed to generate the usage text"
    ;;
    import)
      TEXT=$(cat <<EOF

Usage:
  $VACKUP import [OPTIONS] INPUT VOLUME_NAME
  $VACKUP import [OPTIONS] VOLUME_NAME

Import a docker volume from an archive file

Parameters:
  INPUT           The path to the intput archive file. If the path points to a
                  directory, a file inside the said directory with the name of
                  the volume and archive extension will be assumed
  VOLUME_NAME     The docker volume to import

Options:
  -h, --help      Print this help page
  -s, --stop      Stop running containers that have the specified volume as a
                  mount point before importing, and restart them after

EOF
      ) || error "Failed to generate the usage text"
    ;;
    all)
      TEXT=$(cat <<EOF

Usage: $VACKUP all [OPTIONS] COMMAND

Export/import multiple docker volumes to/from archive files

Commands:
  help        Print this help page
  export      Export multiple docker volumes into archive files
  import      Import multiple docker volumes from archive files

Options:
  -h, --help      Print this help page

Run '$VACKUP all COMMAND --help' for more information on a command.

EOF
      ) || error "Failed to generate the usage text"
    ;;
    export-all)
      TEXT=$(cat <<EOF

Usage: $VACKUP all export [OPTIONS] OUTPUT

Export multiple docker volumes into archive files
All exported archives will be named as the name of the volume and archive
extension, e.g. my_docker_volume.tar.gz

Parameters:
  OUTPUT      The path to the output directory where the archive files will be
              exported to

Options:
  -h, --help        Print this help page
  -p, --parents     Create parent directories for the archive files as needed
  -f, --force       Overwrite the archive files if a file already exists
  -i, --in-use      Only export volumes that are in use by at least one
                    container
  -s, --stop        Stop the running containers that mount a volume before
                    exporting, and restart them after. Takes priority over the
                    -S, --stop-all flag
  -S, --stop-all    Stop all running containers before exporting, and restart
                    them after

EOF
      ) || error "Failed to generate the usage text"
    ;;
    import-all)
      TEXT=$(cat <<EOF

Usage: $VACKUP all import [OPTIONS] INPUT

Import multiple docker volumes from archive files
All imported archives will be assumed to be named as the name of the volume and
archive extension, e.g. my_docker_volume.tar.gz

Parameters:
  INPUT           The path to the intput directory where all the archive files
                  to be imported are

Options:
  -h, --help      Print this help page
  -s, --stop        Stop the running containers that mount a volume before
                    importing, and restart them after. Takes priority over the
                    -S, --stop-all flag
  -S, --stop-all    Stop all running containers before importing, and restart
                    them after

EOF
      ) || error "Failed to generate the usage text"
    ;;
    *)
      warning "'$FOR' is not a recognized print_usage target"

      if [ $STDERR -eq 1 ]; then
        print_usage --err
      else
        print_usage
      fi

      TEXT=''
    ;;
  esac

  if [ $STDERR -eq 1 ]; then
    echo 1>&2 "$TEXT"
  else
    echo 1>&3 "$TEXT"
  fi

  if [ $EXIT -eq 1 ]; then
    if [ $STDERR -eq 1 ]; then
      if [ $CALLER -eq 1 ]; then
        LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
        handle_error $LINE_NUMBER 1
      else
        exit 1
      fi
    else
      exit 0
    fi
  fi
}

# Prints a warning message to STDERR in yellow
# Options:
#   u, usage target (optional): Print usage for the specified target to STDERR after printing the warning message
# Parameters:
#   Message (optional, empty by default): The message to print
warning() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      shift

      if [ $# -gt 0 ]; then
        USAGE="$1"
      else
        USAGE='main'
        warning 'Wrong number of arguments in the warning function'
      fi

      shift
    else
      USAGE=''
    fi

    case $# in
      0) MESSAGE='' ;;
      1) MESSAGE=$1 ;;
      *) MESSAGE=$1; warning 'Wrong number of arguments in the warning function' ;;
    esac

    if [ -n "$MESSAGE" ]; then
      MESSAGE=": $MESSAGE"
    fi
  else
    USAGE=''
    MESSAGE=''
  fi

  printf 1>&2 '%b' "${BOLD_YELLOW_COLOR_ERR}Warning${RESET_COLOR_ERR}${MESSAGE}\n"

  if [ -n "$USAGE" ]; then
    print_usage --err "$USAGE"
  fi
}

# Prints an error message to STDERR in red and exits
# Options:
#   u, usage target (optional): Print usage for the specified target to STDERR after printing the error message
# Parameters:
#   Message (optional, empty by default): The message to print
#   ErrorCode (optional, 1 by default): The error code to exit with
error() {
  if [ $# -gt 0 ]; then
    if [ "$1" = 'u' ] || [ "$1" = 'usage' ]; then
      shift

      if [ $# -gt 0 ]; then
        USAGE="$1"
      else
        USAGE='main'
        warning 'Wrong number of arguments in the error function'
      fi

      shift
    else
      USAGE=''
    fi

    case $# in
      0) MESSAGE=''; CODE=1 ;;
      1) MESSAGE=$1; CODE=1 ;;
      2) MESSAGE=$1; CODE=$2 ;;
      *) MESSAGE=$1; CODE=$2; warning 'Wrong number of arguments in the error function' ;;
    esac

    if [ -n "$MESSAGE" ]; then
      MESSAGE=": $MESSAGE"
    fi
  else
    USAGE=''
    MESSAGE=''
    CODE=1
  fi

  printf 1>&2 '%b' "${BOLD_RED_COLOR_ERR}Error${RESET_COLOR_ERR}${MESSAGE}\n"

  if [ -n "$USAGE" ]; then
    print_usage --err "$USAGE"
  fi

  if [ $CALLER -eq 1 ]; then
    LINE_NUMBER=$(caller | awk '{ print $1 }') || LINE_NUMBER='unknown'
    handle_error $LINE_NUMBER $CODE
  else
    exit $CODE
  fi
}

# Prints an information message to STDOUT in the specified color
# Flags:
#   --{no-color,black,red,green,yellow,blue,purple,cyan,white} (optional, --blue by default): The color of the output
# Parameters:
#   Message (optional, empty by default): The message to print
information() {
  COLOR="$BLUE_COLOR"

  if [ $# -ne 0 ]; then
    case "$1" in
      --*)
        case "$1" in
          --no-color) COLOR="$RESET_COLOR" ;;
          --black) COLOR="$BLACK_COLOR" ;;
          --red) COLOR="$RED_COLOR" ;;
          --green) COLOR="$GREEN_COLOR" ;;
          --yellow) COLOR="$YELLOW_COLOR" ;;
          --blue) COLOR="$BLUE_COLOR" ;;
          --purple) COLOR="$PURPLE_COLOR" ;;
          --cyan) COLOR="$CYAN_COLOR" ;;
          --white) COLOR="$WHITE_COLOR" ;;
          *) warning 'Unrecognized color' ;;
        esac

        shift
      ;;
      *) ;;
    esac
  fi

  case $# in
    1) MESSAGE=$1 ;;
    2) MESSAGE="${COLOR}$1${RESET_COLOR}: $2" ;;
    *) MESSAGE=$1; warning 'Wrong number of arguments in the information function' ;;
  esac

  printf '%b' "$MESSAGE\n"
}

# Splits a string into individual characters, skipping the specified number of characters from the start
# Remark: Iterating over the resulting sequence using a normal for loop will drop all space characters
# Parameters:
#   Skip (optional, 0 by default): The number of characters to skip
#   String (required): The string to split into separate characters
# Return: A newline separated sequence of characters from the input string
chars() {
  case $# in
    1) STR="$1" ;;
    2)
      STR="$2"
      SKIP="$1"

      # Make sure SKIP is not larger than the length of the string
      LEN="${#STR}"
      if [ $LEN -lt $SKIP ]; then
        SKIP="$LEN"
      fi

      # Remove a single character from the start of the string one character at a time
      while [ "$SKIP" -gt 0 ]; do
        STR="${STR#?}"
        SKIP=$((SKIP - 1))
      done
    ;;
    *) STR="$1"; warning 'Wrong number of arguments in the chars function' ;;
  esac

  while [ -n "$STR" ]; do
    # Remove the first character and store the remaining string in a temporary variable
    REST="${STR#?}"

    # Remove REST (everything but the first character) from the end of the string, resulting in the first character only
    CHAR="${STR%"$REST"}"
    echo "$CHAR"

    STR="$REST"
  done
}

# Prefixes every element in a sequence with the specified prefix
# Remark: Iterating over the resulting sequence using a normal for loop will split by any spaces in the prefix
# Parameters:
#   Prefix (required): The prefix to prepend to the start of every element
#   Elements.. (required): The elements to prepend the prefix to
# Return: A newline separated list of prefixed elements
prefix_all() {
  case $# in
    0 | 1) LIST=''; warning 'Wrong number of arguments in the prefix_all function' ;;
    *) PREFIX="$1"; shift; LIST="$@" ;;
  esac

  for ITEM in $LIST; do
    ITEM="$PREFIX$ITEM"
    # Use printf to handle cases where the prefix is a dash ('-') and the item is either 'n', 'e' or 'E'
    printf '%s\n' "$ITEM"
  done
}

# Determines the absolute path to the parent directory
# Parameters:
#   Path (required): The relative or absolute path to a file or directory
# Return: Absolute path to the parent directory, or root if the input path is already root ('/')
fulldirname() {
  DIRECTORY=$(dirname "$1") || error "Failed to get the parent directory for $1"

  case "$DIRECTORY" in
    /*) ;;
    *) DIRECTORY="$(pwd)/$DIRECTORY" ;;
  esac
  DIRECTORY=$(readlink -m "$DIRECTORY") || error "Failed to get the full path for $DIRECTORY"

  echo "$DIRECTORY"
}

# Ensures that the specified path is not an existing file, and appends a slash if missing
# Remark: This function uses and modifies the global DIRECTORY variable
# Parameters:
#   Path (optional, global DIRECTORY variable by default): The path to be tested
assert_is_directory() {
  if [ $# -gt 0 ]; then
    DIRECTORY="$1"
  fi

  case "$DIRECTORY" in
    */) ;;
    *)
      if [ -f "$DIRECTORY" ]; then
        error "'$DIRECTORY' is a file"
      fi

      DIRECTORY="$DIRECTORY/"
    ;;
  esac
}

# Checks if the specified path ends on a slash, or is an existing directory and appends the specified file; Otherwise, leaves the path as is
# Parameters:
#   Path (required): Path to a directory or file
#   File (required): The file name to append to the input path if it's a directory
# Return: If the input path is a directory, the combined path of the directory with the imput file; Otherwise, the original path
append_file_if_dir() {
  DIR_OR_FILE="$1"
  FILE="$2"

  case "$DIR_OR_FILE" in
    */) echo "$DIR_OR_FILE$FILE" ;;
    *)
      if [ -d "$DIR_OR_FILE" ]; then
        echo "$DIR_OR_FILE/$FILE"
      else
        echo "$DIR_OR_FILE"
      fi
    ;;
  esac
}

# Checks if the specified docker volume exists, and prints a warning if it doesn't
# Flags:
#   --error (optional): Exit with an error if the volume doesn't exist. Takes priority over the --create flag
#   --create (optional): Create a new volume if it doesn't exist
# Parameters:
#   VolumeName (optional, global VOLUME_NAME variable by default): The docker volume to be checked
volume_doesnot_exists() {
  ERROR=0
  CREATE=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          --error) ERROR=1 ;;
          --create) CREATE=1 ;;
          *) warning "'$OPTION' is not a recognized volume_doesnot_exists option"
        esac
      ;;
      *) break ;;
    esac
  done

  if [ $# -gt 0 ]; then
    VOLUME_NAME="$1"
  fi

  if ! docker volume inspect --format '{{.Name}}' "$VOLUME_NAME" 1> /dev/null 2>&1; then
    if [ $ERROR -eq 1 ]; then
      error "Volume $VOLUME_NAME does not exist"
    elif [ $CREATE -eq 1 ]; then
      warning "Volume $VOLUME_NAME does not exist, creating..."
      docker volume create "$VOLUME_NAME" 1> /dev/null || error "Failed to create volume $VOLUME_NAME"
    else
      warning "Volume $VOLUME_NAME does not exist"
    fi
  fi
}

# Gets a space separated list of docker volumes
# Remark: This function uses and modifies the global VOLUME_NAMES variable
# Flags:
#   -i, --in-use (optional): Only get volumes in use by at least one container
get_volumes() {
  INUSE=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -i | --in-use) INUSE=1 ;;
          *) warning "'$OPTION' is not a recognized get_volumes option"
        esac
      ;;
      *) break ;;
    esac
  done

  VOLUME_NAMES=$(docker volume ls -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of volumes'

  if [ $INUSE -eq 1 ]; then
    VOLUMES=''

    for VOLUME_NAME in $VOLUME_NAMES; do
      CONTAINERS=$(docker ps -q -a --filter volume="$VOLUME_NAME") || error "Failed to get the list of containers using volume $VOLUME_NAME"

      if [ -n "$CONTAINERS" ]; then
        if [ -z "$VOLUMES" ]; then
          VOLUMES="$VOLUME_NAME"
        else
          VOLUMES="$VOLUMES $VOLUME_NAME"
        fi
      fi
    done

    VOLUME_NAMES="$VOLUMES"
  fi
}

# Gets a space separated list of running container ids
# Remark: This function uses and modifies the global CONTAINERS variable
# Parameters:
#   VolumeNames.. (optional): Only get containers that have one of the specified volumes as a mount point
get_running_containers() {
  if [ $# -eq 0 ]; then
    CONTAINERS=$(docker ps -q | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to get the list of running containers'
  elif [ $# -eq 1 ]; then
    VOLUME_NAME="$1"
    CONTAINERS=$(docker ps -q --filter volume="$VOLUME_NAME" | tr '\n' ' ' | awk '{$1=$1;print}') || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
  else
    CONTAINERS=''
    for VOLUME_NAME in "$@"; do
      TMP=$(docker ps -q --filter volume="$VOLUME_NAME") || error "Failed to get the list of running containers using the $VOLUME_NAME volume"
      CONTAINERS="$CONTAINERS $TMP"
    done
    CONTAINERS=$(echo "$CONTAINERS" | tr '\n' ' ' | awk '{$1=$1;print}') || error 'Failed to remove line separators, and leading and trailing spaces from the list of containers'

    CONTAINERS=$(echo "$CONTAINERS" | tr ' ' '\n' | sort -u | tr '\n' ' ') || error 'Failed to remove duplicates from the list of containers'
  fi
}

# Stops containers defined in the global CONTAINERS variable
# Remark: This function uses the global CONTAINERS variable
stop_containers() {
  if [ -n "$CONTAINERS" ]; then
    information 'Stopping containers' "$CONTAINERS"
    docker stop $CONTAINERS 1> /dev/null || error 'Failed to stop containers'
  fi
}

# Restarts containers defined in the global CONTAINERS variable
# Remark: This function uses the global CONTAINERS variable
restart_containers() {
  if [ -n "$CONTAINERS" ]; then
    information 'Restarting containers' "$CONTAINERS"
    docker restart $CONTAINERS 1> /dev/null || error 'Failed to restart containers'
  fi
}

# The default extension of the exported/imported archive
EXTENSION='tar.gz'

# Exports the specified docker volume into an archive file
# Remark: Supports clustered flags, e.g. -abc instead of -a -b -c
# Flags:
#   -h, --help (optional): Print the usage page
#   -p, --parents (optional): Create parent directories for the archive file as needed
#   -f, --force (optional): Overwrite the archive file if a file already exists
#   -s, --stop (optional): Stop running containers that have the specified volume as a mount point before exporting, and restart them after
# Parameters:
#   VolumeName (required): The docker volume to export
#   Output (optional, ./ by default): The path to the output archive file. If the path points to a directory, a file inside the said directory with the name of the volume and archive extension will be assumed
command_export() {
  PARENTS=0
  OVERWRITE=0
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          -h | --help) print_usage --exit export ;;
          -p | --parents) PARENTS=1 ;;
          -f | --force) OVERWRITE=1 ;;
          -s | --stop) STOP=1 ;;
          *) error usage export "'$OPTION' is not a recognized export option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="./" ;;
    2) VOLUME_NAME="$1"; FILE_NAME="$2" ;;
    *) error usage export 'Wrong number of arguments' ;;
  esac

  FILE_NAME=$(append_file_if_dir "$FILE_NAME" "$VOLUME_NAME.$EXTENSION")
  if [ -f "$FILE_NAME" ]; then
    if [ $OVERWRITE -eq 1 ]; then
      if [ ! -w "$FILE_NAME" ]; then
        error "Unable to write to '$FILE_NAME'"
      fi
    else
      error "File '$FILE_NAME' already exists"
    fi
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME") || error "Faile to get the full path for $FILE_NAME"
  FILE_NAME=$(basename "$FILE_NAME") || error "Failed to get the file name for $FILE_NAME"

  if [ $PARENTS -eq 1 ]; then
    if ! mkdir -p "$DIRECTORY"; then
      error "Failed to make parent directories for '$DIRECTORY/$FILE_NAME'"
    fi
  fi

  if [ ! -w "$DIRECTORY" ]; then
    error "Unable to write to '$DIRECTORY'"
  fi
  assert_is_directory

  volume_doesnot_exists --error

  if [ $STOP -eq 1 ]; then
    get_running_containers "$VOLUME_NAME"
  else
    CONTAINERS=''
  fi

  stop_containers

  TAR_OPTIONS='-zc'
  if [ $VERBOSE -eq 1 ]; then
    TAR_OPTIONS="${TAR_OPTIONS}v"
  fi
  TAR_OPTIONS="${TAR_OPTIONS}f" # Make sure the f option is last, since that's what GNU tar expects

  information 'Exporting volume' "$VOLUME_NAME"
  if [ $HOST -eq 1 ]; then
    MOUNTPOINT=$(docker inspect --format '{{ .Mountpoint }}' "$VOLUME_NAME") || {
      restart_containers
      error 'Failed to get the mountpoint'
    }

    if ! tar $TAR_OPTIONS "$DIRECTORY/$FILE_NAME" -C "$MOUNTPOINT" .; then
      restart_containers
      error 'Failed to tar the volume'
    fi
  else
    if ! docker run --rm \
      -v "$VOLUME_NAME":/vackup-volume:ro \
      -v "$DIRECTORY":/vackup \
      busybox \
      tar $TAR_OPTIONS /vackup/"$FILE_NAME" -C /vackup-volume .; then
      restart_containers
      error 'Failed to start busybox backup container'
    fi
  fi

  restart_containers

  information --green 'Success' "Volume $VOLUME_NAME tar'ed into file '$FILE_NAME'"
}

# Imports the specified docker volume from an archive file
# Remark: Supports clustered flags, e.g. -abc instead of -a -b -c
# Flags:
#   -h, --help (optional): Print the usage page
#   -s, --stop (optional): Stop running containers that have the specified volume as a mount point before importing, and restart them after
# Parameters:
#   Input (optional, ./ by default): The path to the intput archive file. If the path points to a directory, a file inside the said directory with the name of the volume and archive extension will be assumed
#   VolumeName (required): The docker volume to import
command_import() {
  STOP=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          -h | --help) print_usage --exit import ;;
          -s | --stop) STOP=1 ;;
          *) error usage import "'$OPTION' is not a recognized import option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) VOLUME_NAME="$1"; FILE_NAME="./" ;;
    2) FILE_NAME="$1"; VOLUME_NAME="$2" ;;
    *) error usage import 'Wrong number of arguments' ;;
  esac

  FILE_NAME=$(append_file_if_dir "$FILE_NAME" "$VOLUME_NAME.$EXTENSION")
  if [ ! -r "$FILE_NAME" ]; then
    error "Could not find or open '$FILE_NAME'"
  fi

  DIRECTORY=$(fulldirname "$FILE_NAME") || error "Faile to get the full path for $FILE_NAME"
  FILE_NAME=$(basename "$FILE_NAME") || error "Failed to get the file name for $FILE_NAME"
  assert_is_directory

  volume_doesnot_exists --create

  if [ $STOP -eq 1 ]; then
    get_running_containers "$VOLUME_NAME"
    stop_containers
  else
    CONTAINERS=''
  fi

  TAR_OPTIONS='-xz'
  if [ $VERBOSE -eq 1 ]; then
    TAR_OPTIONS="${TAR_OPTIONS}v"
  fi
  TAR_OPTIONS="${TAR_OPTIONS}f" # Make sure the f option is last, since that's what GNU tar expects

  information 'Importing volume' "$VOLUME_NAME"
  if [ $HOST -eq 1 ]; then
    MOUNTPOINT=$(docker inspect --format '{{ .Mountpoint }}' "$VOLUME_NAME") || {
      restart_containers
      error 'Failed to get the mountpoint'
    }

    if ! tar $TAR_OPTIONS "$DIRECTORY/$FILE_NAME" -C "$MOUNTPOINT"; then
      restart_containers
      error 'Failed to extract the tar archive into the volume'
    fi
  else
    if ! docker run --rm \
      -v "$VOLUME_NAME":/vackup-volume \
      -v "$DIRECTORY/$FILE_NAME":"/vackup/$FILE_NAME":ro \
      busybox \
      tar $TAR_OPTIONS /vackup/"$FILE_NAME" -C /vackup-volume; then
      restart_containers
      error 'Failed to start busybox backup container'
    fi
  fi

  restart_containers

  information --green 'Success' "Archive '$FILE_NAME' unpacked into volume $VOLUME_NAME"
}

# Exports all docker volume into archive files
# Remarks:
#   Supports clustered flags, e.g. -abc instead of -a -b -c
#   All exported archives will be named as the name of the volume and archive extension
# Flags:
#   -h, --help (optional): Print the usage page
#   -p, --parents (optional): Create parent directories for the archive files as needed
#   -f, --force (optional): Overwrite the archive files if a file already exists
#   -i, --in-use (optional): Only export volumes that are in use by at least one container
#   -s, --stop (optional): Stop the running containers that mount a volume before exporting, and restart them after. Takes priority over the -S, --stop-all flag
#   -S, --stop-all (optional): Stop all running containers before exporting, and restart them after
# Parameters:
#   Output (required): The path to the output directory where the archive files will be exported to
command_all_export() {
  ARGS=''
  INUSE=0
  STOP=0
  STOP_ALL=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          -h | --help) print_usage --exit export-all ;;
          -p | --parents) ARGS="$ARGS --parents" ;;
          -f | --force) ARGS="$ARGS --force" ;;
          -i | --in-use) INUSE=1 ;;
          -s | --stop) STOP=1 ;;
          -S | --stop-all) STOP_ALL=1 ;;
          *) error usage export-all "'$OPTION' is not a recognized export option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1"; assert_is_directory ;;
    *) error usage export-all 'Wrong number of arguments' ;;
  esac

  if [ $INUSE -eq 1 ]; then
    get_volumes --in-use
  else
    get_volumes
  fi

  if [ $STOP -eq 1 ] || [ $STOP_ALL -eq 1 ]; then
    if [ $STOP -eq 1 ]; then
      get_running_containers $VOLUME_NAMES
    else
      get_running_containers
    fi

    stop_containers
  else
    CONTAINERS=''
  fi

  for VOLUME_NAME in $VOLUME_NAMES; do
    if ! (command_export $ARGS "$VOLUME_NAME" "$DIRECTORY"); then
      restart_containers
      error "Failed during $VOLUME_NAME volume export"
    fi
  done

  restart_containers

  information --green 'Success' "Volumes [$VOLUME_NAMES] tar'ed into archive files"
}

# Imports all docker volume from archive files
# Remarks:
#   Supports clustered flags, e.g. -abc instead of -a -b -c
#   All imported archives will be assumed to be named as the name of the volume and archive extension
# Flags:
#   -h, --help (optional): Print the usage page
#   -s, --stop (optional): Stop the running containers that mount a volume before importing, and restart them after. Takes priority over the -S, --stop-all flag
#   -S, --stop-all (optional): Stop all running containers before importing, and restart them after
# Parameters:
#   Input (required): The path to the intput directory where all the archive files to be imported are
command_all_import() {
  ARGS=''
  STOP=0
  STOP_ALL=0

  while [ $# -ne 0 ]; do
    case "$1" in
      -*)
        OPTION="$1"
        shift

        case "$OPTION" in
          -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$OPTION")) "$@" ;;
          -h | --help) print_usage --exit import-all ;;
          -s | --stop) STOP=1 ;;
          -S | --stop-all) STOP_ALL=1 ;;
          *) error usage import-all "'$OPTION' is not a recognized import option" ;;
        esac
      ;;
      *) break ;;
    esac
  done

  case $# in
    1) DIRECTORY="$1"; assert_is_directory ;;
    *) error usage import-all 'Wrong number of arguments' ;;
  esac

  get_volumes

  if [ $STOP -eq 1 ] || [ $STOP_ALL -eq 1 ]; then
    if [ $STOP -eq 1 ]; then
      get_running_containers $VOLUME_NAMES
    else
      get_running_containers
    fi

    stop_containers
  else
    CONTAINERS=''
  fi

  SUCCESSFUL=''
  for VOLUME_NAME in $VOLUME_NAMES; do
    FILE_NAME="$DIRECTORY$VOLUME_NAME.$EXTENSION"

    if [ ! -f "$FILE_NAME" ]; then
      warning "'$FILE_NAME' was not found, skipping import of '$VOLUME_NAME' volume"
      continue
    fi

    if ! (command_import $ARGS "$FILE_NAME" "$VOLUME_NAME"); then
      restart_containers
      error "Failed during $VOLUME_NAME volume import"
    fi

    if [ -z "$SUCCESSFUL" ]; then
      SUCCESSFUL="$VOLUME_NAME"
    else
      SUCCESSFUL="$SUCCESSFUL $VOLUME_NAME"
    fi
  done

  restart_containers

  information --green 'Success' "Archives unpacked into volumes [$SUCCESSFUL]"
}

# Command for importing/exporting all volumes
# Remark: Supports clustered flags, e.g. -abc instead of -a -b -c
# Flags:
#   -h, --help (optional): Print the usage page
# Parameters:
#   Subcommand (required): One of help, export or import. All subsequent arguments will be forwarded to the specified subcommand
command_all() {
  while [ $# -gt 0 ]; do
    COMMAND="$1"
    shift

    case "$COMMAND" in
      -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$COMMAND")) "$@" ;;
      -h | --help | help) print_usage --exit all ;;
      export) command_all_export "$@"; exit 0 ;;
      import) command_all_import "$@"; exit 0 ;;
      all | *) error usage all "'$COMMAND' is not a recognized command" ;;
    esac
  done

  print_usage --exit all
}

# Redirect any output on the 3rd file descriptor to STDOUT, which is used to print messages even when STDOUT has been silenced
exec 3>&1

VERBOSE=0
HOST=0

# Argument parsing
# Remark: Supports clustered flags, e.g. -abc instead of -a -b -c
# Flags:
#   -h, --help (optional): Print the usage page
#   -q, --quiet (optional): Silence the outputs to STDOUT, except if the usage page is explicitly requested
#   -v, --verbose (optional): Verbose printing
#   -H, --host (optional): Do the export/import by running the archive program on the host instead of a container
# Parameters:
#   Command (required): One of help, export, import or all. All subsequent arguments will be forwarded to the specified command
while [ $# -gt 0 ]; do
  COMMAND="$1"
  shift

  case "$COMMAND" in
    -[A-Za-z][A-Za-z]*) set -- $(prefix_all - $(chars 1 "$COMMAND")) "$@" ;;
    -h | --help | help) print_usage --exit ;;
    -q | --quiet) exec 3>&1 1>/dev/null ;;
    -v | --verbose) VERBOSE=1 ;;
    -H | --host) HOST=1 ;;
    export) command_export "$@"; exit 0 ;;
    import) command_import "$@"; exit 0 ;;
    all) command_all "$@"; exit 0 ;;
    *) error usage main "'$COMMAND' is not a recognized command" ;;
  esac
done

print_usage --exit

exit 0
